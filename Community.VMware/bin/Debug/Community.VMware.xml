<?xml version="1.0" encoding="utf-8"?>
<ManagementPack SchemaVersion="2.0" ContentReadable="true" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Manifest>
    <Identity>
      <ID>Community.VMware</ID>
      <Version>1.0.2.114</Version>
    </Identity>
    <Name>Community.VMware</Name>
    <References>
      <Reference Alias="MSDL">
        <ID>Microsoft.SystemCenter.DataWarehouse.Library</ID>
        <Version>10.19.10050.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSIL">
        <ID>Microsoft.SystemCenter.InstanceGroup.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8443.6</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSNL">
        <ID>Microsoft.SystemCenter.NTService.Library</ID>
        <Version>10.19.10050.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Unix">
        <ID>Microsoft.Unix.Library</ID>
        <Version>10.19.1123.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8443.6</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Perf">
        <ID>System.Performance.Library</ID>
        <Version>7.0.8443.6</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SVL">
        <ID>System.Virtualization.Library</ID>
        <Version>7.0.8443.6</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <EntityTypes>
      <ClassTypes>
        <ClassType ID="Community.VMware.Class.Cluster" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="ClusterName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="ClusterId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="HAEnabled" Type="string" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Datacenter" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="DatacenterName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="DatacenterId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Datastore" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="DatastoreName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="DatastoreId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Group.AllObjects" Accessibility="Public" Base="MSIL!Microsoft.SystemCenter.InstanceGroup" Abstract="false" Hosted="false" Singleton="true"></ClassType>
        <ClassType ID="Community.VMware.Class.Group.ClustersWithoutHA" Accessibility="Public" Base="MSIL!Microsoft.SystemCenter.InstanceGroup" Abstract="false" Hosted="false" Singleton="true"></ClassType>
        <ClassType ID="Community.VMware.Class.Group.Rollup.vCenter" Accessibility="Public" Base="MSIL!Microsoft.SystemCenter.InstanceGroup" Abstract="false" Hosted="false" Singleton="true"></ClassType>
        <ClassType ID="Community.VMware.Class.Group.UnmonitoredVirtualMachines" Accessibility="Public" Base="MSIL!Microsoft.SystemCenter.InstanceGroup" Abstract="false" Hosted="false" Singleton="true"></ClassType>
        <ClassType ID="Community.VMware.Class.Host" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="HostName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="HostId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="IsStandalone" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Network" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="NetworkName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="NetworkId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.ResourcePool" Base="SC!Microsoft.SystemCenter.ManagementServicePool" Accessibility="Public" Abstract="false" Hosted="false" Singleton="true"></ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.vCenter" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="false" Singleton="false">
          <Property ID="vCenterServerName" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="DatacenterName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="DatacenterId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="ClusterName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="ClusterId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="HostName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="HostId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" Base="System!System.LogicalEntity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="Name" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.vApp" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="vAppName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="vAppId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.vCenter" Base="System!System.Entity" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="vCenterServerName" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Community.VMware.Class.vCenterServerService" Base="MSNL!Microsoft.SystemCenter.NTService" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false"></ClassType>
        <ClassType ID="Community.VMware.Class.VirtualMachine" Base="SVL!System.VirtualMachine" Accessibility="Public" Abstract="false" Hosted="true" Singleton="false">
          <Property ID="VirtualMachineName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="VirtualMachineHostName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="VirtualMachineId" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
      </ClassTypes>
      <RelationshipTypes>
        <RelationshipType ID="Community.VMware.Relationship.ClusterContainsHost" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Host" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.ClusterReferencesDatacenter" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Datacenter" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.HostReferencesDatacenter" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Host" />
          <Target ID="Target" Type="Community.VMware.Class.Datacenter" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.HostReferencesDatastore" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Host" />
          <Target ID="Target" Type="Community.VMware.Class.Datastore" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.HostReferencesNetwork" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Host" />
          <Target ID="Target" Type="Community.VMware.Class.Network" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.ResourcePoolHostsvCenter" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.ResourcePool" />
          <Target ID="Target" Type="Community.VMware.Class.vCenter" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.vCenterHostsHostsAndClusters" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClustersHostsDatacenter" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllClusters" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllStandaloneHosts" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.AllClustersHostsCluster" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsVirtualMachines" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsDatastores" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsNetworks" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsvApps" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.AllStandaloneHostsHostsStandaloneHost" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsVirtualMachines" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsDatastores" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsNetworks" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsvApps" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" />
          <Target ID="Target" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterContainsCluster" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" />
          <Target ID="Target" Type="Community.VMware.Class.Cluster" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterVirtualMachinesContainsVirtualMachine" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" />
          <Target ID="Target" Type="Community.VMware.Class.VirtualMachine" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterDatastoresContainsDatastore" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" />
          <Target ID="Target" Type="Community.VMware.Class.Datastore" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterNetworksContainsNetwork" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" />
          <Target ID="Target" Type="Community.VMware.Class.Network" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClustervAppsContainsvApp" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" />
          <Target ID="Target" Type="Community.VMware.Class.vApp" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostContainsHost" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" />
          <Target ID="Target" Type="Community.VMware.Class.Host" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesContainsVirtualMachine" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" />
          <Target ID="Target" Type="Community.VMware.Class.VirtualMachine" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostDatastoresContainsDatastore" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" />
          <Target ID="Target" Type="Community.VMware.Class.Datastore" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostNetworksContainsNetwork" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" />
          <Target ID="Target" Type="Community.VMware.Class.Network" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostvAppsContainsvApp" Base="System!System.Containment" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" />
          <Target ID="Target" Type="Community.VMware.Class.vApp" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vAppReferencesCluster" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vApp" />
          <Target ID="Target" Type="Community.VMware.Class.Cluster" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vAppReferencesHost" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vApp" />
          <Target ID="Target" Type="Community.VMware.Class.Host" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsCluster" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.Cluster" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsDatacenter" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.Datacenter" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsDatastore" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.Datastore" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsHost" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.Host" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsNetwork" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.Network" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsvApp" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.vApp" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.vCenterHostsVirtualMachine" Base="System!System.Hosting" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.vCenter" />
          <Target ID="Target" Type="Community.VMware.Class.VirtualMachine" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.VirtualMachineReferencesDatastore" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.VirtualMachine" />
          <Target ID="Target" Type="Community.VMware.Class.Datastore" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.VirtualMachineReferencesHost" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.VirtualMachine" />
          <Target ID="Target" Type="Community.VMware.Class.Host" />
        </RelationshipType>
        <RelationshipType ID="Community.VMware.Relationship.VirtualMachineReferencesNetwork" Base="System!System.Reference" Abstract="false" Accessibility="Internal">
          <Source ID="Source" Type="Community.VMware.Class.VirtualMachine" />
          <Target ID="Target" Type="Community.VMware.Class.Network" />
        </RelationshipType>
      </RelationshipTypes>
    </EntityTypes>
    <SecureReferences>
      <SecureReference ID="Community.VMware.SecureReference.RunAsProfile" Accessibility="Public" />
    </SecureReferences>
    <ModuleTypes>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.ClusterDatastorePerf">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="ClusterDatastorePerfProbe">
                <ScriptName>Community.VMware.Probe.ClusterDatastorePerf.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.ClusterDatastorePerf.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#   $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    $date=Get-Date
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }


	exit
}
Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append LogFIle
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append }

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		ExitPrematurely ("Unable to load VMware Module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Server $vCenter" | Out-File $EnhancedLoggingPath  -append}
        
$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
    $VMclustersView = Get-View -Server $connection -ViewType ComputeResource -Property Datastore | Select Datastore,MoRef
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Clusters View: $VMclustersView" | Out-File $EnhancedLoggingPath  -append}
    }
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMclustersView){
	LogScriptEvent 0 ("No clusters found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No clisters found in vCenter")
}

Try {
    $VMdatastores = Get-View -Server $connection -ViewType Datastore -Property Summary | Select Summary
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Datastores: $VMdatastores" | Out-File $EnhancedLoggingPath  -append}

    }
Catch {DefaultErrorLogging -vCenter $vCenter}
    
If (!$VMdatastores){
	LogScriptEvent 0 ("No datastores found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely("No Datastores fount in vCenter")
}
   
ForEach ($VMcluster in $VMclustersView){
        
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Cluster: $VMcluster" | Out-File $EnhancedLoggingPath  -append}

	$CAPACITY_GB	= 0
	$FREE_GB		= 0
	$USED_GB		= 0
	$FREE_Percent	= 0
	$USED_Percent	= 0
	
	ForEach ($VMclusterDataStore in $VMcluster.Datastore){
	
		$VMdatastoreView = $VMdatastores | Where {$_.Summary.Datastore -eq [string]$VMclusterDataStore}
		if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datastore view:$VMdatastores" | Out-File $EnhancedLoggingPath  -append}
		If ($VMdatastoreView){
		
			$Store_CAPACITY_GB	= $VMdatastoreView.Summary.Capacity * (9.31323e-10)
			$Store_FREE_GB		= $VMdatastoreView.Summary.FreeSpace * (9.31323e-10)
			$Store_USED_GB		= ($VMdatastoreView.Summary.Capacity - $VMdatastoreView.Summary.FreeSpace)*(9.31323e-10)
			
			$CAPACITY_GB	= $CAPACITY_GB + $Store_CAPACITY_GB
			$FREE_GB		= $FREE_GB + $Store_FREE_GB
			$USED_GB		= $USED_GB + $Store_USED_GB
		}
	}
	
	If ($CAPACITY_GB -ne 0){
		$FREE_Percent	= [math]::Round((($FREE_GB * 100)/$CAPACITY_GB) , 2)
		$USED_Percent	= [math]::Round((($USED_GB * 100)/$CAPACITY_GB) , 2)
	}
	$CAPACITY_GB	= [math]::Round($CAPACITY_GB, 2)
	$FREE_GB		= [math]::Round($FREE_GB, 2) 
	$USED_GB		= [math]::Round($USED_GB, 2)
	
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('ClusterId', [string]$VMcluster.MoRef)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('CAPACITY_GB',$CAPACITY_GB)
	$bag.AddValue('FREE_GB',$FREE_GB)
	$bag.AddValue('USED_GB',$USED_GB)
	$bag.AddValue('FREE_Percent',$FREE_Percent)
	$bag.AddValue('USED_Percent',$USED_Percent)
	$bag
}

    
$date=Get-Date
do {

	Disconnect-VIServer -Server $connection -Confirm:$false
    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, Exiting" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter Successfully" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterCluster">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='ClusterId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/ClusterId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection TypeID="Perf!System.Performance.DataGenericMapper" ID="MapToPerf">
                <ObjectName>VMware Cluster</ObjectName>
                <CounterName>$Config/CounterName$</CounterName>
                <InstanceName>$Config/ClusterName$</InstanceName>
                <Value>$Data/Property[@Name='$Config/PerfValueName$']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="MapToPerf">
                <Node ID="FilterCluster">
                  <Node ID="ClusterDatastorePerfProbe">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Internal" ID="Community.VMware.DataSource.ClusterDatastorePerfOptimized">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" maxOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" maxOccurs="1" name="MaximumSampleSeparation" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Tolerance" ParameterType="double" Selector="$Config/Tolerance$" />
          <OverrideableParameter ID="MaximumSampleSeparation" ParameterType="int" Selector="$Config/MaximumSampleSeparation$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="Community.VMware.DataSource.ClusterDatastorePerf" ID="ClusterDatastorePerfDS">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
                <ClusterId>$Config/ClusterId$</ClusterId>
                <ClusterName>$Config/ClusterName$</ClusterName>
                <CounterName>$Config/CounterName$</CounterName>
                <PerfValueName>$Config/PerfValueName$</PerfValueName>
              </DataSource>
              <ConditionDetection TypeID="Perf!System.Performance.OptimizedCollectionFilter" ID="OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/IntervalSeconds$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedCollectionFilter">
                <Node ID="ClusterDatastorePerfDS" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.ClusterPerf">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="ClusterPerfProbe">
                <ScriptName>Community.VMware.Probe.ClusterPerf.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName,$IntervalSeconds)

$ScriptName = 'Community.VMware.Probe.ClusterPerf.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
  
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName,  Interval Seconds: $IntervalSeconds" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
    LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")
	
    #Append LogFIle
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append}

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging
		ExitPrematurely("Unable to import VMware Module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter Server: $vCenter" | Out-File $EnhancedLoggingPath  -append}
        
$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {$VMclusters = Get-Cluster -Server $connection}
Catch {
    DefaultErrorLogging -vCenter $vCenter
}

If (!$VMclusters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No clusters found in vCenter server " | Out-File $EnhancedLoggingPath -append  }

	LogScriptEvent 0 ("No clusters found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}
	ExitPrematurely("No Clusters found in vCenter")
}

$Stats = ('cpu.usage.average','mem.usage.average')
Try {

    $VMclustersPerf = $VMclusters | Get-Stat -Stat $Stats -Start $(Get-Date).AddSeconds(-$IntervalSeconds) -MaxSamples 1
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"CM Clusters Perf: $VMclustersPerf" | Out-File $EnhancedLoggingPath -append  }

}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}

If (!$VMclustersPerf){
	LogScriptEvent 0 ("No cluster performance counters in vCenter server " + $vCenter)
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No cluster performance counters in vCenter server " + $vCenter| Out-File $EnhancedLoggingPath -append  }

	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No cluster performance counters in vCenter server $vCenter" | Out-File $EnhancedLoggingPath  -append}
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}
	ExitPrematurely("No Cluster Performance Counter in vCenter")
}

ForEach ($VMcluster in $VMclusters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Cluster: $VMcluster" | Out-File $EnhancedLoggingPath  -append}
    $CPU_Percent	= [math]::Round(($VMclustersPerf | Where {($_.Entity.Id -eq $VMcluster.Id) -and ($_.MetricId -eq 'cpu.usage.average')}).Value)
	$MEM_Percent	= [math]::Round(($VMclustersPerf | Where {($_.Entity.Id -eq $VMcluster.Id) -and ($_.MetricId -eq 'mem.usage.average')}).Value)

	$bag = $api.CreatePropertyBag()
	$bag.AddValue('ClusterId', $VMcluster.Id)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('cpu.usage.average',$CPU_Percent)
	$bag.AddValue('mem.usage.average',$MEM_Percent)
	$bag
}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnecting from $connection" | Out-File $EnhancedLoggingPath  -append}
    
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}


if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>IntervalSeconds</Name>
                    <Value>$Config/IntervalSeconds$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterCluster">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='ClusterId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/ClusterId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection TypeID="Perf!System.Performance.DataGenericMapper" ID="MapToPerf">
                <ObjectName>VMware Cluster</ObjectName>
                <CounterName>$Config/CounterName$</CounterName>
                <InstanceName>$Config/ClusterName$</InstanceName>
                <Value>$Data/Property[@Name='$Config/PerfValueName$']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="MapToPerf">
                <Node ID="FilterCluster">
                  <Node ID="ClusterPerfProbe">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Internal" ID="Community.VMware.DataSource.ClusterPerfOptimized">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" maxOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" maxOccurs="1" name="MaximumSampleSeparation" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Tolerance" ParameterType="double" Selector="$Config/Tolerance$" />
          <OverrideableParameter ID="MaximumSampleSeparation" ParameterType="int" Selector="$Config/MaximumSampleSeparation$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="Community.VMware.DataSource.ClusterPerf" ID="ClusterPerfDS">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
                <ClusterId>$Config/ClusterId$</ClusterId>
                <ClusterName>$Config/ClusterName$</ClusterName>
                <CounterName>$Config/CounterName$</CounterName>
                <PerfValueName>$Config/PerfValueName$</PerfValueName>
              </DataSource>
              <ConditionDetection TypeID="Perf!System.Performance.OptimizedCollectionFilter" ID="OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/IntervalSeconds$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedCollectionFilter">
                <Node ID="ClusterPerfDS" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.ClusterState">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="ClusterStateProbe">
                <ScriptName>Community.VMware.Probe.ClusterState.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.ClusterState.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}Else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -Append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging ($vCenter, $EnhancedLogging) {
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")
	
	#Append LogFIle
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter"  | Out-File $EnhancedLoggingPath -append }


}


Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenterServerName -EnhancedLogging $EnhancedLogging
		ExitPrematurely("Unable to import VMware Module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Connecting to vCenter Server: $vcenter" | Out-File $EnhancedLoggingPath  -append}

$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
    $VMclusters = Get-View -Server $connection -ViewType ClusterComputeResource -Property Summary | Select Summary, MoRef
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Clusters found: $VMclusters " | Out-File $EnhancedLoggingPath  -append}
}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}

ForEach ($VMcluster in $VMclusters){

	$bag = $api.CreatePropertyBag()
	$bag.AddValue('ClusterId', [string]$VMcluster.MoRef)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('CurrentFailoverLevel', $VMcluster.Summary.CurrentFailoverLevel)
	$bag
}

$date=Get-Date
do {
	Disconnect-VIServer -Server $connection -Confirm:$false  
    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}


if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterCluster">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='ClusterId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/ClusterId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="FilterCluster">
                <Node ID="ClusterStateProbe">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.DatacenterDatastorePerf">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatacenterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatacenterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="DatacenterDatastorePerfProbe">
                <ScriptName>Community.VMware.Probe.DatacenterDatastorePerf.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.DatacenterDatastorePerf.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append Logs
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append }

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -EnhancedLogging  $EnhancedLogging 
		ExitPrematurely("Unable to load VMware Module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "Connecting to vCenter Server: $vCenter" | Out-File $EnhancedLoggingPath -append }

$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}
Try {
    $VMdatacentersView = Get-View -Server $connection -ViewType Datacenter -Property Datastore | Select Datastore,MoRef
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "VM Datacenter View returned: $VMdatacentersView"| Out-File $EnhancedLoggingPath -append }
}
Catch {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Datastore View: $VMdatastores" | Out-File $EnhancedLoggingPath  -append}
    DefaultErrorLogging -vCenter $vCenter -EnhancedLogging  $EnhancedLogging
}

If (!$VMdatacentersView){
	LogScriptEvent 0 ("No datacenters found in vCenter server " + $vCenter)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "No VM Datacenter View availible"| Out-File $EnhancedLoggingPath -append }
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging  $EnhancedLogging}
	#ExitPrematurely("No Datacenter found in vCenter server")
}

Try {
    $VMdatastores = Get-View -Server $connection -ViewType Datastore -Property Summary | Select Summary
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "VM Datasore View returned: $VMdatastores"| Out-File $EnhancedLoggingPath -append }    
}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging  $EnhancedLogging}

If (!$VMdatastores){
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "No VM Datastores View availible"| Out-File $EnhancedLoggingPath -append }
    LogScriptEvent 0 ("No datastores found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging  $EnhancedLogging}
	#ExitPrematurely("No Datastore found in vCenter Server")
}

ForEach ($VMdatacenter in $VMdatacentersView){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "Current Datacenter: $VMdatacenter "| Out-File $EnhancedLoggingPath -append }

	$CAPACITY_GB	= 0
	$FREE_GB		= 0
	$USED_GB		= 0
	$CAPACITY_TB	= 0
	$FREE_TB		= 0
	$USED_TB		= 0

	ForEach ($VMdatastore in $VMdatacenter.Datastore){

        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "Current Datastore: $VMdatastores "| Out-File $EnhancedLoggingPath -append }
		    
        $VMdatastoreView = $VMdatastores | Where {$_.Summary.Datastore -eq [string]$VMdatastore}
		if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "Current Datastore View: $VMdatastoreView "| Out-File $EnhancedLoggingPath -append }

		If ($VMdatastoreView){
			
			$Store_CAPACITY_GB	= $VMdatastoreView.Summary.Capacity * (9.31323e-10)
			$Store_FREE_GB		= $VMdatastoreView.Summary.FreeSpace * (9.31323e-10)
			$Store_USED_GB		= ($VMdatastoreView.Summary.Capacity - $VMdatastoreView.Summary.FreeSpace)*(9.31323e-10)
			$Store_CAPACITY_TB	= $VMdatastoreView.Summary.Capacity * (9.09495e-13)
			$Store_FREE_TB		= $VMdatastoreView.Summary.FreeSpace * (9.09495e-13)
			$Store_USED_TB		= ($VMdatastoreView.Summary.Capacity - $VMdatastoreView.Summary.FreeSpace)*(9.09495e-13)
			
			$CAPACITY_GB	= $CAPACITY_GB + $Store_CAPACITY_GB
			$FREE_GB		= $FREE_GB + $Store_FREE_GB
			$USED_GB		= $USED_GB + $Store_USED_GB
			$CAPACITY_TB	= $CAPACITY_TB + $Store_CAPACITY_TB
			$FREE_TB		= $FREE_TB + $Store_FREE_TB
			$USED_TB		= $USED_TB + $Store_USED_TB
		}
	}
	
	If ($CAPACITY_GB -ne 0){
		$FREE_Percent	= [math]::Round((($FREE_GB * 100)/$CAPACITY_GB) , 2)
		$USED_Percent	= [math]::Round((($USED_GB * 100)/$CAPACITY_GB) , 2)
	}
	$CAPACITY_GB	= [math]::Round($CAPACITY_GB, 2)
	$FREE_GB		= [math]::Round($FREE_GB, 2)
	$USED_GB		= [math]::Round($USED_GB, 2)
	$CAPACITY_TB	= [math]::Round($CAPACITY_TB, 2)
	$FREE_TB		= [math]::Round($FREE_TB, 2)
	$USED_TB		= [math]::Round($USED_TB, 2)
	
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('DatacenterId', [string]$VMdatacenter.MoRef)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('CAPACITY_GB',$CAPACITY_GB)
	$bag.AddValue('FREE_GB',$FREE_GB)
	$bag.AddValue('USED_GB',$USED_GB)
	$bag.AddValue('FREE_Percent',$FREE_Percent)
	$bag.AddValue('CAPACITY_TB',$CAPACITY_TB)
	$bag.AddValue('FREE_TB',$FREE_TB)
	$bag.AddValue('USED_TB',$USED_TB)
	$bag
}
    
$date=Get-Date
do {
	Disconnect-VIServer -Server $connection -Confirm:$false  
    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterDatacenter">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='DatacenterId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/DatacenterId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection TypeID="Perf!System.Performance.DataGenericMapper" ID="MapToPerf">
                <ObjectName>VMware Datacenter</ObjectName>
                <CounterName>$Config/CounterName$</CounterName>
                <InstanceName>$Config/DatacenterName$</InstanceName>
                <Value>$Data/Property[@Name='$Config/PerfValueName$']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="MapToPerf">
                <Node ID="FilterDatacenter">
                  <Node ID="DatacenterDatastorePerfProbe">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Internal" ID="Community.VMware.DataSource.DatacenterDatastorePerfOptimized">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatacenterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatacenterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" maxOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" maxOccurs="1" name="MaximumSampleSeparation" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Tolerance" ParameterType="double" Selector="$Config/Tolerance$" />
          <OverrideableParameter ID="MaximumSampleSeparation" ParameterType="int" Selector="$Config/MaximumSampleSeparation$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="Community.VMware.DataSource.DatacenterDatastorePerf" ID="DatacenterDatastorePerfDS">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
                <DatacenterId>$Config/DatacenterId$</DatacenterId>
                <DatacenterName>$Config/DatacenterName$</DatacenterName>
                <CounterName>$Config/CounterName$</CounterName>
                <PerfValueName>$Config/PerfValueName$</PerfValueName>
              </DataSource>
              <ConditionDetection TypeID="Perf!System.Performance.OptimizedCollectionFilter" ID="OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/IntervalSeconds$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedCollectionFilter">
                <Node ID="DatacenterDatastorePerfDS" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.DatastorePerf">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="DatastorePerfProbe">
                <ScriptName>Community.VMware.Probe.DatastorePerf.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.DatastorePerf.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
  
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}Else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -Append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		ExitPrematurely("Unable to load VMware Module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter Server Name: $vCenter" |  Out-File $EnhancedLoggingPath -append   }
    
$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
    $VMdatastores = Get-View -Server $connection -ViewType Datastore -Property Summary | Select Summary
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Datastore View: $VMdatastores" | Out-File $EnhancedLoggingPath  -append}
}
Catch {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Datastore View: $VMdatastores" | Out-File $EnhancedLoggingPath  -append}
    DefaultErrorLogging -vCenter $vCenter
}

If (!$VMdatastores){
	LogScriptEvent 0 ("No datastores found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	#ExitPrematurely("No datastores found in vCenter server")
}

ForEach ($VMdatastore in $VMdatastores){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter $vcenter,   VM Datastore: $($VMdatastore.Summary.Name)" |  Out-File $EnhancedLoggingPath -append   }

	$CAPACITY_GB	= [math]::Round($VMdatastore.Summary.Capacity * (9.31323e-10), 2)
	$FREE_GB		= [math]::Round($VMdatastore.Summary.FreeSpace * (9.31323e-10), 2)
	$USED_GB		= [math]::Round(($VMdatastore.Summary.Capacity - $VMdatastore.Summary.FreeSpace)*(9.31323e-10) , 2)
	$FREE_Percent	= [math]::Round(($VMdatastore.Summary.FreeSpace * 100)/$VMdatastore.Summary.Capacity, 2)
	$USED_Percent	= [math]::Round(($VMdatastore.Summary.Capacity - $VMdatastore.Summary.FreeSpace)*100/$VMdatastore.Summary.Capacity, 2)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"  vCenter $vcenter,   VM Datastore: $($VMdatastore.Summary.Name),  Capacity (GB) $CAPACITY_GB" |  Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"  vCenter $vcenter,   VM Datastore: $($VMdatastore.Summary.Name),  Free Space (GB) $FREE_GB" |  Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"  vCenter $vcenter,   VM Datastore: $($VMdatastore.Summary.Name),  Used Space (GB) $USED_GB" |  Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"  vCenter $vcenter,   VM Datastore: $($VMdatastore.Summary.Name),  Free Space (%) $FREE_Percent" |  Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"  vCenter $vcenter,   VM Datastore: $($VMdatastore.Summary.Name),  Used Space (%) $USED_Percent" |  Out-File $EnhancedLoggingPath -append   }

	$bag = $api.CreatePropertyBag()
	$bag.AddValue('DatastoreId', [string]$VMdatastore.Summary.Datastore)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('CAPACITY_GB',$CAPACITY_GB)
	$bag.AddValue('FREE_GB',$FREE_GB)
	$bag.AddValue('USED_GB',$USED_GB)
	$bag.AddValue('FREE_Percent',$FREE_Percent)
	$bag.AddValue('USED_Percent',$USED_Percent)
	$bag
}

$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}


if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>IntervalSeconds</Name>
                    <Value>$Config/IntervalSeconds$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterDatastore">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='DatastoreId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/DatastoreId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection TypeID="Perf!System.Performance.DataGenericMapper" ID="MapToPerf">
                <ObjectName>VMware Datastore</ObjectName>
                <CounterName>$Config/CounterName$</CounterName>
                <InstanceName>$Config/DatastoreName$</InstanceName>
                <Value>$Data/Property[@Name='$Config/PerfValueName$']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="MapToPerf">
                <Node ID="FilterDatastore">
                  <Node ID="DatastorePerfProbe">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Internal" ID="Community.VMware.DataSource.DatastorePerfOptimized">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" maxOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" maxOccurs="1" name="MaximumSampleSeparation" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Tolerance" ParameterType="double" Selector="$Config/Tolerance$" />
          <OverrideableParameter ID="MaximumSampleSeparation" ParameterType="int" Selector="$Config/MaximumSampleSeparation$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="Community.VMware.DataSource.DatastorePerf" ID="DatastorePerfDS">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
                <DatastoreId>$Config/DatastoreId$</DatastoreId>
                <DatastoreName>$Config/DatastoreName$</DatastoreName>
                <CounterName>$Config/CounterName$</CounterName>
                <PerfValueName>$Config/PerfValueName$</PerfValueName>
              </DataSource>
              <ConditionDetection TypeID="Perf!System.Performance.OptimizedCollectionFilter" ID="OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/IntervalSeconds$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedCollectionFilter">
                <Node ID="DatastorePerfDS" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.DatastoreState">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="DatastoreStateProbe">
                <ScriptName>Community.VMware.Probe.DatastoreState.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.DatastoreState.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
  
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -Append}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")
	
    #Append Logs
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath  -append}

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		ExitPrematurely ("Unable to import VMware module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter Server Name: $vCenter" |  Out-File $EnhancedLoggingPath -append   }

$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
    $VMdatastores = Get-Datastore -Server $connection | Select Id,State
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" VM Datasores for $vCenter $VMdatastores" | Out-File $EnhancedLoggingPath -append  }
}
Catch {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Datastore View: $VMdatastores" | Out-File $EnhancedLoggingPath  -append}
    DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging
}


ForEach ($VMdatastore in $VMdatastores){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Processing VM Datasore: $VMdatastore" | Out-File $EnhancedLoggingPath -append  }
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('DatastoreId',$VMdatastore.Id)
	$bag.AddValue('vCenterServerName', $vCenter)
	$bag.AddValue('State',($VMdatastore.State.ToString()))
	$bag
}

$date=Get-Date
do {
	Disconnect-VIServer -Server $connection -Confirm:$false  
    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterDatastore">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='DatastoreId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/DatastoreId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="FilterDatastore">
                <Node ID="DatastoreStateProbe">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.HostDatastorePerf">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsStandalone" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="HostDatastorePerfProbe">
                <ScriptName>Community.VMware.Probe.HostDatastorePerf.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.HostDatastorePerf.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
  
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")
	
	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		ExitPrematurely ("enable to load VMware Module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter " | Out-File $EnhancedLoggingPath -append   }

param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.HostDatacenterReference.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $SourceID,  Managed Entity Id: $managedEntityId,  vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	
	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }
}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging -vCenter $vCenter}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging -vCenter $vCenter}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging -vCenter $vCenter}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}



Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter
		ExitPrematurely ("Unable to import VMware module")
	}
}

    
$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
        
    $VMwareDatacenters = Get-Datacenter -Server $connection
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datacenters: " + $VMwareDatacenters| Out-File $EnhancedLoggingPath -append   }
}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareDatacenters){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	#ExitPrematurely ("No VM Datacenters found in vCenter " + $vCenter)
}

ForEach ($VMdatacenter in $VMwareDatacenters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datacenter: " + $VMwareDatacenter| Out-File $EnhancedLoggingPath -append   }

	#Verify VMdatacenter is in SCOM
	If ($VMdatacenterObjs | Where {$_.'[Community.VMware.Class.Datacenter].DatacenterId'.Value -eq [string]$VMdatacenter.Id}){
            
		#Get VMhosts in this datacenter
		Try {
            $VMhostsInDatacenter = $VMdatacenter | Get-VMHost | Get-View -Property Name | Select Name,MoRef

        }
		Catch {DefaultErrorLogging -vCenter $vCenter}

		If ($VMhostsInDatacenter){
		    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: $VMhostsInDatacenter  in Datacenter: " + $VMdatacenter| Out-File $EnhancedLoggingPath -append   }

			#VM datacenter Obj (already discovered)
			$VMdatacenterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datacenter']$")
			$VMdatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datacenter']/DatacenterId$", [string]$VMdatacenter.Id )
			$VMdatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
			ForEach ($VMhost in $VMhostsInDatacenter){
			
				#Verify Host is in SCOM
				If ($VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VMhost.MoRef}){
                    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: " + $VMhost| Out-File $EnhancedLoggingPath -append   }
					#VM Host Obj (already discovered)
					$VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
					$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$VMhost.MoRef )
					$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
					
					#Host references Datacenter
					$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.HostReferencesDatacenter']$")
					$rel1.Source = $VMhostInstance
					$rel1.Target = $VMdatacenterInstance
					$discoveryData.AddInstance($rel1)
				}
			}
		}
	}
}
$date=Get-Date

do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)



if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
Exit

if($connection.IsConnected -ne $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

Try {
    $VMhostsView = Get-View -Server $connection -ViewType ComputeResource -Property Datastore | Select Datastore,MoRef
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Hosts View: $VMhostsView " | Out-File $EnhancedLoggingPath -append   }
    
}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMhostsView){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No VM Hosts found in View. " | Out-File $EnhancedLoggingPath -append   }
	LogScriptEvent 0 ("No hosts found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	#exit
}

Try {
    
    $VMdatastores = Get-View -Server $connection -ViewType Datastore -Property Summary | Select Summary
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datastores: $VMdatastores " | Out-File $EnhancedLoggingPath -append   }

}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMdatastores){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No datastores found in vCenter server " + $vCenter | Out-File $EnhancedLoggingPath -append   }
	LogScriptEvent 0 ("No datastores found in vCenter server " + $vCenter)
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	#exit
}

ForEach ($VMhost in $VMhostsView){

	$VMhostStores = $VMdatastores | Where {[string]$_.Summary.Datastore -eq [string]$VMhost.Datastore}
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: " + $VMhost | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host Stores: " + $VMhostStores | Out-File $EnhancedLoggingPath -append   }
	$CAPACITY_GB	= 0
	$FREE_GB		= 0
	$USED_GB		= 0
	
	ForEach ($VMhostDataStore in $VMhostStores){
		
		$Store_CAPACITY_GB	= $VMhostDataStore.Summary.Capacity * (9.31323e-10)
		$Store_FREE_GB		= $VMhostDataStore.Summary.FreeSpace * (9.31323e-10)
		$Store_USED_GB		= ($VMhostDataStore.Summary.Capacity - $VMhostDataStore.Summary.FreeSpace)*(9.31323e-10)
		
		$CAPACITY_GB	= $CAPACITY_GB + $Store_CAPACITY_GB
		$FREE_GB		= $FREE_GB + $Store_FREE_GB
		$USED_GB		= $USED_GB + $Store_USED_GB
	}
	
	If ($CAPACITY_GB -ne 0){
		$FREE_Percent	= [math]::Round((($FREE_GB * 100)/$CAPACITY_GB) , 2)
		$USED_Percent	= [math]::Round((($USED_GB * 100)/$CAPACITY_GB) , 2)
	}
	$CAPACITY_GB	= [math]::Round($CAPACITY_GB, 2)
	$FREE_GB		= [math]::Round($FREE_GB, 2) 
	$USED_GB		= [math]::Round($USED_GB, 2)
	
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('HostId', [string]$VMhost.MoRef)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('CAPACITY_GB',$CAPACITY_GB)
	$bag.AddValue('FREE_GB',$FREE_GB)
	$bag.AddValue('USED_GB',$USED_GB)
	$bag.AddValue('FREE_Percent',$FREE_Percent)
	$bag.AddValue('USED_Percent',$USED_Percent)
	$bag
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterHost">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='HostId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/HostId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">True</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/IsStandalone$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection TypeID="Perf!System.Performance.DataGenericMapper" ID="MapToPerf">
                <ObjectName>VMware Host</ObjectName>
                <CounterName>$Config/CounterName$</CounterName>
                <InstanceName>$Config/HostName$</InstanceName>
                <Value>$Data/Property[@Name='$Config/PerfValueName$']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="MapToPerf">
                <Node ID="FilterHost">
                  <Node ID="HostDatastorePerfProbe">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Internal" ID="Community.VMware.DataSource.HostDatastorePerfOptimized">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsStandalone" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" maxOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" maxOccurs="1" name="MaximumSampleSeparation" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Tolerance" ParameterType="double" Selector="$Config/Tolerance$" />
          <OverrideableParameter ID="MaximumSampleSeparation" ParameterType="int" Selector="$Config/MaximumSampleSeparation$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="Community.VMware.DataSource.HostDatastorePerf" ID="HostDatastorePerfDS">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
                <HostId>$Config/HostId$</HostId>
                <HostName>$Config/HostName$</HostName>
                <IsStandalone>$Config/IsStandalone$</IsStandalone>
                <CounterName>$Config/CounterName$</CounterName>
                <PerfValueName>$Config/PerfValueName$</PerfValueName>
              </DataSource>
              <ConditionDetection TypeID="Perf!System.Performance.OptimizedCollectionFilter" ID="OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/IntervalSeconds$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedCollectionFilter">
                <Node ID="HostDatastorePerfDS" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.HostPerf">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="HostPerfProbe">
                <ScriptName>Community.VMware.Probe.HostPerf.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)


$ScriptName = 'Community.VMware.Probe.HostPerf.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
  
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerNames: $vCenter" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)

    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter"  | Out-File $EnhancedLoggingPath -append   }


}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


Try {
    $VMhosts = Get-View -Server $connection -ViewType HostSystem -Property Summary | Select Summary
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Trying to get host view from $vCenterServerName" | Out-File $EnhancedLoggingPath -append }  
}
Catch {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"failed to get host view from $vCenterServerName" | Out-File $EnhancedLoggingPath -append }  
    DefaultErrorLogging -vCenter $vCenterServerName
}
    
ForEach ($VMhost in $VMhosts){

    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: $VMHost" | Out-File $EnhancedLoggingPath -append   }
	$CPU_UsageMHz	= $VMhost.Summary.QuickStats.OverallCpuUsage
	$CPU_MaxMHz		= $VMhost.Summary.Hardware.CpuMhz * $VMhost.Summary.Hardware.NumCpuCores
	$CPU_FreeMHz	= $CPU_MaxMHz - $CPU_UsageMHz
	$CPU_Percent	= [math]::Round($CPU_UsageMHz*100/$CPU_MaxMHz)
	
	$MEM_UsageMB	= $VMhost.Summary.QuickStats.OverallMemoryUsage
	$MEM_MaxMB		= [math]::Round($VMhost.Summary.Hardware.MemorySize/1048576)
	$MEM_FreeMB		= $MEM_MaxMB - $MEM_UsageMB
	$MEM_Percent	= [math]::Round($MEM_UsageMB*100/$MEM_MaxMB)

	$bag = $api.CreatePropertyBag()
	$bag.AddValue('HostId',[string]$VMhost.Summary.Host)
	$bag.AddValue('vCenterServerName',$vCenter)
	$bag.AddValue('CPU_UsageMHz',$CPU_UsageMHz)
	$bag.AddValue('CPU_MaxMHz',$CPU_MaxMHz)
	$bag.AddValue('CPU_FreeMHz',$CPU_FreeMHz)
	$bag.AddValue('CPU_Percent',$CPU_Percent)
	$bag.AddValue('MEM_UsageMB',$MEM_UsageMB)
	$bag.AddValue('MEM_MaxMB',$MEM_MaxMB)
	$bag.AddValue('MEM_FreeMB',$MEM_FreeMB)
	$bag.AddValue('MEM_Percent',$MEM_Percent)
	$bag
}
    
$date=Get-Date
do {
	Disconnect-VIServer -Server $connection -Confirm:$false  
    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenterServerName" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenterServerName
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenterServerName" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenterServerName finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }


Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterHost">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='HostId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/HostId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection TypeID="Perf!System.Performance.DataGenericMapper" ID="MapToPerf">
                <ObjectName>VMware Host</ObjectName>
                <CounterName>$Config/CounterName$</CounterName>
                <InstanceName>$Config/HostName$</InstanceName>
                <Value>$Data/Property[@Name='$Config/PerfValueName$']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="MapToPerf">
                <Node ID="FilterHost">
                  <Node ID="HostPerfProbe">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Internal" ID="Community.VMware.DataSource.HostPerfOptimized">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" maxOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" maxOccurs="1" name="MaximumSampleSeparation" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="Tolerance" ParameterType="double" Selector="$Config/Tolerance$" />
          <OverrideableParameter ID="MaximumSampleSeparation" ParameterType="int" Selector="$Config/MaximumSampleSeparation$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="Community.VMware.DataSource.HostPerf" ID="HostPerfDS">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
                <HostId>$Config/HostId$</HostId>
                <HostName>$Config/HostName$</HostName>
                <CounterName>$Config/CounterName$</CounterName>
                <PerfValueName>$Config/PerfValueName$</PerfValueName>
              </DataSource>
              <ConditionDetection TypeID="Perf!System.Performance.OptimizedCollectionFilter" ID="OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/IntervalSeconds$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedCollectionFilter">
                <Node ID="HostPerfDS" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Perf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.HostState">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="HostStateProbe">
                <ScriptName>Community.VMware.Probe.HostState.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.HostState.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}



if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter " + $vCenter   | Out-File $EnhancedLoggingPath -append   }

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
    $VMhosts = Get-View -Server $connection -ViewType HostSystem -Property Runtime | Select Runtime,MoRef
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Hosts: $VMhosts " | Out-File $EnhancedLoggingPath -append   }
}
Catch {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM  Datastore View: $VMdatastores" | Out-File $EnhancedLoggingPath  -append}
    DefaultErrorLogging -vCenter $vCenter
}


ForEach ($VMhost in $VMhosts){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Processing VMHost: $VMhost " | Out-File $EnhancedLoggingPath -append   }
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('HostId', [string]$VMhost.MoRef)
	$bag.AddValue('vCenterServerName', $vCenter)
	$bag.AddValue('PowerState',[string]$VMhost.Runtime.PowerState)
	$bag
}


$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterHost">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='HostId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/HostId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="FilterHost">
                <Node ID="HostStateProbe">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.NetworkState">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NetworkId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="NetworkStateProbe">
                <ScriptName>Community.VMware.Probe.NetworkState.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.NetworkState.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"ini server names: $($a.content.vCenterServerNames) " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }
#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"   =============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Logging level: $EnhancedLogging Log folder: $EnhancedLoggingPath " | Out-File $EnhancedLoggingPath -append   }

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter: $vCenter "| Out-File $EnhancedLoggingPath -append   }
    
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


    
Try {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Getting view from $vCenter using `$connection = $($connection.Name)" | Out-File $EnhancedLoggingPath -append   }
       
    $Networks = Get-View -Server $connection -ViewType Network

}
Catch {
    Start-Sleep -Seconds 15
    Try {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Getting view from $vCenter using `$vCenter = $vcenter" | Out-File $EnhancedLoggingPath -append   }
        $Networks = Get-View -Server $vCenter -ViewType Network
        #$Networks = Get-View -Server $connection -ViewType Network

    }
    Catch {
        Start-Sleep -Seconds 15
        Try {
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Getting view from $vCenter using `$vCenter = $vcenter" | Out-File $EnhancedLoggingPath -append   }
            $Networks = Get-View -Server $vCenter -ViewType Network
            #$Networks = Get-View -Server $connection -ViewType Network

        }
        Catch {
        DefaultErrorLogging -vCenter $vCenter
        }
    }
}

ForEach ($Network in $Networks){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Found Network: $Network" | Out-File $EnhancedLoggingPath -append   }
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('NetworkId', [string]$Network.MoRef)
	$bag.AddValue('vCenterServerName', $vCenter)
	$bag.AddValue('OverallStatus',[string]$Network.OverallStatus)
	$bag
}

$date=Get-Date
do {
	Disconnect-VIServer -Server $connection -Confirm:$false  
    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}


if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterNetwork">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='NetworkId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/NetworkId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="FilterNetwork">
                <Node ID="NetworkStateProbe">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.vAppState">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vAppId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="vAppStateProbe">
                <ScriptName>Community.VMware.Probe.vAppState.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.vAppState.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }
#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}
Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }
}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter: $vCenter "| Out-File $EnhancedLoggingPath -append   }

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}



Try {$vApps = Get-View -Server $connection -ViewType VirtualApp -Property Summary | Select Summary,MoRef}
Catch {DefaultErrorLogging -vCenter $vCenter}

#
#If (!$vApps){
#    LogScriptEvent 0 ("No vApps found in vCenter server " + $vCenter)
#    Try {Disconnect-VIServer -Server $connection -Confirm:$false}
#    Catch {DefaultErrorLogging -vCenter $vCenter}
#    exit
#}
#

ForEach ($vApp in $vApps){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Found vApp: $vApp "| Out-File $EnhancedLoggingPath -append   }
	$bag = $api.CreatePropertyBag()
	$bag.AddValue('vAppId', [string]$vApp.MoRef)
	$bag.AddValue('vCenterServerName', $vCenter)
	$bag.AddValue('State',[string]$vApp.Summary.VAppState)
	$bag
}
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FiltervApp">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vAppId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vAppId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="FiltervApp">
                <Node ID="vAppStateProbe">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType Accessibility="Public" ID="Community.VMware.DataSource.VirtualMachineState">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="VirtualMachineId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="System!System.SimpleScheduler" ID="Scheduler">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
              </DataSource>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe" ID="VirtualMachineStateProbe">
                <ScriptName>Community.VMware.Probe.VirtualMachineState.ps1</ScriptName>
                <ScriptBody><![CDATA[param($vCenterServerName)

$ScriptName = 'Community.VMware.Probe.VirtualMachineState.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
  
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
    
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append  }

}


Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Current vCenter $vCenter " | Out-File $EnhancedLoggingPath -append   }


$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    Exit
}

Try {
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Attempting to get VM View using `$connection = $($connection.name) " | Out-File $EnhancedLoggingPath -append   }
    $VirtualMachines = Get-View -Server $connection -ViewType VirtualMachine -Property Summary | Select Summary,MoRef
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Attempting to get VM View: $($VirtualMachines | Select *) " | Out-File $EnhancedLoggingPath -append   }

}Catch{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"View connection using `$connection = $($connection.name) failed, retrying in 15 seconds using `$vCenter = $vCenter" | Out-File $EnhancedLoggingPath -append   }

    Start-Sleep -Seconds 15
    Try{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Attempting to get VM View using `$vCenter = $($vCenter) " | Out-File $EnhancedLoggingPath -append   }
        $VirtualMachines = Get-View -Server $vCenter -ViewType VirtualMachine -Property Summary | Select Summary,MoRef

    }Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"View connection to $vCenter failed, giving up" | Out-File $EnhancedLoggingPath -append   }

        DefaultErrorLogging
    }
}


ForEach ($VirtualMachine in $VirtualMachines){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"    adding bag infor for VM $VirtualMachine" | Out-File $EnhancedLoggingPath -append   }

	$bag = $api.CreatePropertyBag()
	$bag.AddValue('VirtualMachineId', [string]$VirtualMachine.MoRef)
	$bag.AddValue('vCenterServerName', $vCenter)
	$bag.AddValue('PowerState',[string]$VirtualMachine.Summary.Runtime.PowerState)
	$bag
}

$date=Get-Date

do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter: $vCenter,   $($connection | Select *)" | Out-File $EnhancedLoggingPath -append} 
        #DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.seconds(30) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter: $vCenter,   $($connection | Select *)" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>vCenterServerName</Name>
                    <Value>$Config/vCenterServerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection TypeID="System!System.ExpressionFilter" ID="FilterVirtualMachine">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='VirtualMachineId']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/VirtualMachineId$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='vCenterServerName']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/vCenterServerName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="FilterVirtualMachine">
                <Node ID="VirtualMachineStateProbe">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.ClusterCurentFailoverLevelBelowThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.ClusterState" ID="ClusterStateDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <ClusterId>$Config/ClusterId$</ClusterId>
            </DataSource>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Property[@Name='CurrentFailoverLevel']</XPathQuery>
                  </ValueExpression>
                  <Operator>GreaterEqual</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/WarningThreshold$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Property[@Name='CurrentFailoverLevel']</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/WarningThreshold$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ClusterStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ClusterStateDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.ClusterDatastorePerfBelowThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CriticalThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="CriticalThreshold" Selector="$Config/CriticalThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.ClusterDatastorePerf" ID="ClusterDatastorePerfDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <ClusterId>$Config/ClusterId$</ClusterId>
              <ClusterName>$Config/ClusterName$</ClusterName>
              <CounterName>$Config/CounterName$</CounterName>
              <PerfValueName>$Config/PerfValueName$</PerfValueName>
            </DataSource>
            <ConditionDetection TypeID="Perf!System.Performance.ConsecutiveSamplesCondition" ID="ConsecutiveSampleCondition">
              <Threshold>$Config/WarningThreshold$</Threshold>
              <Direction>lessequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/WarningThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>Greater</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="ClusterDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="ClusterDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="ClusterDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.ClusterPerfAboveThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ClusterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CriticalThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="CriticalThreshold" Selector="$Config/CriticalThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.ClusterPerf" ID="ClusterPerfDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <ClusterId>$Config/ClusterId$</ClusterId>
              <ClusterName>$Config/ClusterName$</ClusterName>
              <CounterName>$Config/CounterName$</CounterName>
              <PerfValueName>$Config/PerfValueName$</PerfValueName>
            </DataSource>
            <ConditionDetection TypeID="Perf!System.Performance.ConsecutiveSamplesCondition" ID="ConsecutiveSampleCondition">
              <Threshold>$Config/WarningThreshold$</Threshold>
              <Direction>greaterequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/WarningThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>Less</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="ClusterPerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="ClusterPerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="ClusterPerfDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.DatacenterDatastorePerfBelowThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatacenterId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatacenterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CriticalThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="CriticalThreshold" Selector="$Config/CriticalThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.DatacenterDatastorePerf" ID="DatacenterDatastorePerfDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <DatacenterId>$Config/DatacenterId$</DatacenterId>
              <DatacenterName>$Config/DatacenterName$</DatacenterName>
              <CounterName>$Config/CounterName$</CounterName>
              <PerfValueName>$Config/PerfValueName$</PerfValueName>
            </DataSource>
            <ConditionDetection TypeID="Perf!System.Performance.ConsecutiveSamplesCondition" ID="ConsecutiveSampleCondition">
              <Threshold>$Config/WarningThreshold$</Threshold>
              <Direction>lessequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/WarningThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>Greater</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="DatacenterDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="DatacenterDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="DatacenterDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.DatastorePerfBelowThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CriticalThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="CriticalThreshold" Selector="$Config/CriticalThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.DatastorePerf" ID="DatastorePerfDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <DatastoreId>$Config/DatastoreId$</DatastoreId>
              <DatastoreName>$Config/DatastoreName$</DatastoreName>
              <CounterName>$Config/CounterName$</CounterName>
              <PerfValueName>$Config/PerfValueName$</PerfValueName>
            </DataSource>
            <ConditionDetection TypeID="Perf!System.Performance.ConsecutiveSamplesCondition" ID="ConsecutiveSampleCondition">
              <Threshold>$Config/WarningThreshold$</Threshold>
              <Direction>lessequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/WarningThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>Greater</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="DatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="DatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="DatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.DatastoreState">
        <MonitorTypeStates>
          <MonitorTypeState ID="Available" />
          <MonitorTypeState ID="Unavailable" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DatastoreId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.DatastoreState" ID="DatastoreStateDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <DatastoreId>$Config/DatastoreId$</DatastoreId>
            </DataSource>
            <ConditionDetection ID="AvailableCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Available</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="UnavailableCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>NotEqual</Operator>
                  <ValueExpression>
                    <Value Type="String">Available</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Available">
              <Node ID="AvailableCondition">
                <Node ID="DatastoreStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Unavailable">
              <Node ID="UnavailableCondition">
                <Node ID="DatastoreStateDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.HostDatastorePerfBelowThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsStandalone" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CriticalThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="CriticalThreshold" Selector="$Config/CriticalThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.HostDatastorePerf" ID="HostDatastorePerfDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <HostId>$Config/HostId$</HostId>
              <HostName>$Config/HostName$</HostName>
              <IsStandalone>$Config/IsStandalone$</IsStandalone>
              <CounterName>$Config/CounterName$</CounterName>
              <PerfValueName>$Config/PerfValueName$</PerfValueName>
            </DataSource>
            <ConditionDetection TypeID="Perf!System.Performance.ConsecutiveSamplesCondition" ID="ConsecutiveSampleCondition">
              <Threshold>$Config/WarningThreshold$</Threshold>
              <Direction>lessequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/WarningThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>Greater</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Double">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Double">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="HostDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="HostDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="HostDatastorePerfDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.HostPerfAboveThreshold">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="PerfValueName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="WarningThreshold" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CriticalThreshold" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="WarningThreshold" Selector="$Config/WarningThreshold$" ParameterType="int" />
          <OverrideableParameter ID="CriticalThreshold" Selector="$Config/CriticalThreshold$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.HostPerf" ID="HostPerfDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <HostId>$Config/HostId$</HostId>
              <HostName>$Config/HostName$</HostName>
              <CounterName>$Config/CounterName$</CounterName>
              <PerfValueName>$Config/PerfValueName$</PerfValueName>
            </DataSource>
            <ConditionDetection TypeID="Perf!System.Performance.ConsecutiveSamplesCondition" ID="ConsecutiveSampleCondition">
              <Threshold>$Config/WarningThreshold$</Threshold>
              <Direction>greaterequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/WarningThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>Less</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Value</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/NumSamples$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">SampleValue</XPathQuery>
                      </ValueExpression>
                      <Operator>GreaterEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">$Config/CriticalThreshold$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="HostPerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="HostPerfDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalCondition">
                <Node ID="ConsecutiveSampleCondition">
                  <Node ID="HostPerfDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.HostPowerState">
        <MonitorTypeStates>
          <MonitorTypeState ID="PoweredOn" />
          <MonitorTypeState ID="NotPoweredOn" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="HostId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.HostState" ID="HostStateDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <HostId>$Config/HostId$</HostId>
            </DataSource>
            <ConditionDetection ID="PoweredOnCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='PowerState']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">poweredOn</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="NotPoweredOnCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='PowerState']</XPathQuery>
                  </ValueExpression>
                  <Operator>NotEqual</Operator>
                  <ValueExpression>
                    <Value Type="String">poweredOn</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="PoweredOn">
              <Node ID="PoweredOnCondition">
                <Node ID="HostStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="NotPoweredOn">
              <Node ID="NotPoweredOnCondition">
                <Node ID="HostStateDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.NetworkOverallStatus">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" />
          <MonitorTypeState ID="Warning" />
          <MonitorTypeState ID="Critical" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NetworkId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.NetworkState" ID="NetworkStateDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <NetworkId>$Config/NetworkId$</NetworkId>
            </DataSource>
            <ConditionDetection ID="HealthyExpression" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Or>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='OverallStatus']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">green</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='OverallStatus']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">gray</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </Or>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningExpression" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='OverallStatus']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">yellow</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="CriticalExpression" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='OverallStatus']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">red</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="HealthyExpression">
                <Node ID="NetworkStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="WarningExpression">
                <Node ID="NetworkStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Critical">
              <Node ID="CriticalExpression">
                <Node ID="NetworkStateDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.vAppStartedState">
        <MonitorTypeStates>
          <MonitorTypeState ID="Started" />
          <MonitorTypeState ID="NotStarted" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vAppId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.vAppState" ID="vAppStateDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <vAppId>$Config/vAppId$</vAppId>
            </DataSource>
            <ConditionDetection ID="StartedCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">started</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="NotStartedCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>NotEqual</Operator>
                  <ValueExpression>
                    <Value Type="String">started</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Started">
              <Node ID="StartedCondition">
                <Node ID="vAppStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="NotStarted">
              <Node ID="NotStartedCondition">
                <Node ID="vAppStateDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType Accessibility="Public" ID="Community.VMware.MonitorType.VirtualMachinePowerState">
        <MonitorTypeStates>
          <MonitorTypeState ID="PoweredOn" />
          <MonitorTypeState ID="NotPoweredOn" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="vCenterServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="VirtualMachineId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="vCenterServerName" Selector="$Config/vCenterServerName$" ParameterType="string" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Community.VMware.DataSource.VirtualMachineState" ID="VirtualMachineStateDS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <vCenterServerName>$Config/vCenterServerName$</vCenterServerName>
              <VirtualMachineId>$Config/VirtualMachineId$</VirtualMachineId>
            </DataSource>
            <ConditionDetection ID="PoweredOnCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='PowerState']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">poweredOn</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="NotPoweredOnCondition" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='PowerState']</XPathQuery>
                  </ValueExpression>
                  <Operator>NotEqual</Operator>
                  <ValueExpression>
                    <Value Type="String">poweredOn</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="PoweredOn">
              <Node ID="PoweredOnCondition">
                <Node ID="VirtualMachineStateDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="NotPoweredOn">
              <Node ID="NotPoweredOnCondition">
                <Node ID="VirtualMachineStateDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Categories>
    <Category ID="Community.VMware.Image.Cluster.Diagram.Category" Target="Community.VMware.Image.Cluster.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.Cluster.Small.Category" Target="Community.VMware.Image.Cluster.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.Datacenter.Diagram.Category" Target="Community.VMware.Image.Datacenter.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.Datacenter.Small.Category" Target="Community.VMware.Image.Datacenter.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.Datastore.Diagram.Category" Target="Community.VMware.Image.Datastore.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.Datastore.Small.Category" Target="Community.VMware.Image.Datastore.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.Host.Diagram.Category" Target="Community.VMware.Image.Host.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.Host.Small.Category" Target="Community.VMware.Image.Host.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.Network.Diagram.Category" Target="Community.VMware.Image.Network.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.Network.Small.Category" Target="Community.VMware.Image.Network.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.vApp.Diagram.Category" Target="Community.VMware.Image.vApp.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.vApp.Small.Category" Target="Community.VMware.Image.vApp.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.vCenter.Diagram.Category" Target="Community.VMware.Image.vCenter.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.vCenter.Small.Category" Target="Community.VMware.Image.vCenter.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
    <Category ID="Community.VMware.Image.VirtualMachine.Diagram.Category" Target="Community.VMware.Image.VirtualMachine.Diagram" Value="System!System.Internal.ManagementPack.Images.DiagramIcon" />
    <Category ID="Community.VMware.Image.VirtualMachine.Small.Category" Target="Community.VMware.Image.VirtualMachine.Small" Value="System!System.Internal.ManagementPack.Images.u16x16Icon" />
  </Categories>
  <Monitoring>
    <Discoveries>
      <Discovery ID="Community.VMware.Discovery.Cluster" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.Cluster" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsCluster" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:10</SyncTime>
          <ScriptName>Community.VMware.Discovery.Cluster.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.Cluster.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    } 
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}



$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}

$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }



Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
}


Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	#Append LogFIle

	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter"  | Out-File $EnhancedLoggingPath -append }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
        # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
		ExitPrematurely( "Unable to load VMware Module")
	}
}

$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    Exit
}

Try {$VMclusters = Get-Cluster -Server $connection | Select Name,Id,HAEnabled}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMclusters){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false	}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No clusters found in vCenter " + $vCenter)
}

ForEach ($Cluster in $VMclusters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "VMware Cluster: $Cluster" | Out-File $EnhancedLoggingPath -append }
	#Cluster Obj
	$ClusterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Cluster']$")
	$ClusterObj.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/ClusterName$", $Cluster.Name )
	$ClusterObj.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/ClusterId$", $Cluster.Id )
	$ClusterObj.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/HAEnabled$", [string]($Cluster.HAEnabled))
	$ClusterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
	$ClusterObj.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $Cluster.Name )
	$discoveryData.AddInstance($ClusterObj)
	
	#vCenter Obj (already discovered)
	$vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	$vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	#vCenter Hosts Cluster
	$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsCluster']$")
	$rel1.Source = $vCenterObj
	$rel1.Target = $ClusterObj
	$discoveryData.AddInstance($rel1)
}
    
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter

		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "Discovery Data: $discoveryData" | Out-File $EnhancedLoggingPath -append }
$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.ClusterDatacenterReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.ClusterReferencesDatacenter" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>21600</IntervalSeconds>
          <SyncTime>01:00</SyncTime>
          <ScriptName>Community.VMware.Discovery.ClusterDatacenterReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.ClusterDatacenterReference.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}


#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }



Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
	$discoveryData
    $date=Get-Date
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }


	exit
}


Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	
    # apped to log file
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes"){"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -Append}
}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

#Get Already Discovered Datacenters from SCOM
Try {$VMdatacenterObjs = Get-SCOMClass -Name 'Community.VMware.Class.Datacenter' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMdatacenterObjs){
	ExitPrematurely ("No VM Datacenters found discovered in SCOM for vCenter " + $vCenter)
}

#Get Already Discovered VM Clusters from SCOM
Try {$VMclusterObjs = Get-SCOMClass -Name 'Community.VMware.Class.Cluster' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

#Exit if no VM Clusters were discovered, because there is no relationship to build
If (!$VMclusterObjs){
	ExitPrematurely ("No VM Clusters found discovered in SCOM for vCenter " + $vCenter)
}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter
		ExitPrematurely("Unable to load VMware Module")
	}
}

        
$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
	$VMwareDatacenters = Get-Datacenter -Server $connection
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "VMData Center: $VMwareDatacenters"  | Out-File "$LogfileLocation$ScriptName.log"  -append}

}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareDatacenters){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No VM Datacenters found in vCenter " + $vCenter)
}

ForEach ($VMdatacenter in $VMwareDatacenters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datacenter: $VMdatacenter " | Out-File $EnhancedLoggingPath -append   }

	#Verify VMdatacenter is in SCOM
	If ($VMdatacenterObjs | Where {$_.'[Community.VMware.Class.Datacenter].DatacenterId'.Value -eq [string]$VMdatacenter.Id}){

		#Get VM Clusters in this datacenter
		$VMclustersInDatacenter = $VMdatacenter | Get-Cluster | Get-View -Property Name | Select Name,MoRef

		If ($VMclustersInDatacenter){
		
			#VM datacenter Obj (already discovered)
			$VMdatacenterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datacenter']$")
			$VMdatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datacenter']/DatacenterId$", [string]$VMdatacenter.Id )
			$VMdatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
			ForEach ($VMcluster in $VMclustersInDatacenter){
			    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"    VM Cluster: $VMcluster   For Datacenter: $VMdatacenter " | Out-File $EnhancedLoggingPath -append   }

				#Verify Cluster is in SCOM
				If ($VMclusterObjs | Where {$_.'[Community.VMware.Class.Cluster].ClusterId'.Value -eq [string]$VMcluster.MoRef}){

					#VM Cluster Obj (already discovered)
					$VMclusterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Cluster']$")
					$VMclusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/ClusterId$", [string]$VMcluster.MoRef )
					$VMclusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
					
					#Cluster references Datacenter
					$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.ClusterReferencesDatacenter']$")
					$rel1.Source = $VMclusterInstance
					$rel1.Target = $VMdatacenterInstance
					$discoveryData.AddInstance($rel1)
				}
			}
		}
	}
}

$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData


if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }


Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.ClusterHostContainment" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.ClusterContainsHost" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>21600</IntervalSeconds>
          <SyncTime>01:05</SyncTime>
          <ScriptName>Community.VMware.Discovery.ClusterHostContainment.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)
$ScriptName = 'Community.VMware.Discovery.ClusterHostContainment.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#

$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"SorceID: $sourceId,  Managed Entity ID: $managedEntityId,  vCenter Server Name: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


Function ExitPrematurely ($Message){
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Discovery Data: $discoveryData" | Out-File $EnhancedLoggingPath -append }

	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }

}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	
	#Append LogFIle
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append }

}

$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}


$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

#Get Already Discovered Hosts from SCOM
Try {$VMhostbjs = Get-SCOMClass -Name 'Community.VMware.Class.Host' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLoggingr}

If (!$VMhostbjs){
	ExitPrematurely ("No VM Hosts found discovered in SCOM for vCenter " + $vCenter)
}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging
		ExitPrematurely("Unable to import VMware Module")
	}
}

$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        $ExistingConnection=Get-VIServer -Server $vCenter -NotDefault  
        if($ExistingConnection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"attempting to connet to existing session $a.SessionId on vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }
		    $connection = Connect-VIServer -Server $vCenter -Force:$true -session $ExistingConnection.SessionId -NotDefault 

    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No existing session on vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
    }

        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
	        Start-Sleep -Seconds 10
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)


    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passed, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely("No vCenter passed to script")
}

Try {$VMwareClusters = (Get-View -Server $connection -ViewType ClusterComputeResource -Property Host) | Select Host,MoRef}
Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}

If (!$VMwareClusters){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging $EnhancedLogging}
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No VM Clusters found in vCenter " + $vCenter | Out-File $EnhancedLoggingPath -append  }
	ExitPrematurely ("No VM Clusters found in vCenter " + $vCenter)
}

ForEach ($VMcluster in $VMwareClusters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Cluster: $VVMcluster" | Out-File $EnhancedLoggingPath -append }

	If ($VMclusterObjs | Where {$_.'[Community.VMware.Class.Cluster].ClusterId'.Value -eq [string]$VMcluster.MoRef}){

		#VM Host Obj (already discovered)
		$VMclusterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Cluster']$")
		$VMclusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/ClusterId$", [string]$VMcluster.MoRef )
		$VMclusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
		ForEach ($VMhost in $VMcluster.Host){

			$MatchingHost = $VMhostbjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VMHost}
			If ($MatchingHost){

				#Host Obj (already discovered)
				$VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
				$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$MatchingHost.'[Community.VMware.Class.Host].HostId'.Value )
				$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
				
				#Cluster Contains Host
				$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.ClusterContainsHost']$")
				$rel1.Source = $VMclusterInstance
				$rel1.Target = $VMhostInstance
				$discoveryData.AddInstance($rel1)
			}
		}
	}
}
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Discovery Data: $discoveryData" | Out-File $EnhancedLoggingPath -append }

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Datacenter" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.Datacenter" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsDatacenter" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:05</SyncTime>
          <ScriptName>Community.VMware.Discovery.Datacenter.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.Datacenter.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }


if(($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
    $vCenterServerName=($a.content.vCenterServerNames).split(",")
}else{$vCenter=$vCenterServerName}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "Source ID: $sourceId,  Management Entity ID: $managedEntityId,  vCenter Server Name: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	
	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter"  | Out-File $EnhancedLoggingPath -append }


}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {
    $discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)
}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging vCenter $vCenter -EnhancedLogging  $EnhancedLogging
		ExitPrematurely("Unable to import VMware Module")
	}
}

foreach($vCenter in $vCenterServerName | Where-Object {$_ -ne $null -and $_ -ne ""}){

    $ExistingConnection=$null
    $date=Get-Date
    if($vCenter -ne $null -and $vcenter -ne ""){
    
        do {
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
            $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
            if($connection.IsConnected -ne $true){
                if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	            DefaultErrorLogging -vCenter $vCenter
                #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	            Start-Sleep -Seconds 10
            
   	        }
            $Now=Get-Date
        }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
            DefaultErrorLogging -vCenter $vCenter
            ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
        }Else{
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        }
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

        ExitPrematurely ("No vCenter Server Name passes, Exiting")
    }

    Try {$VMdatacenters = Get-View -Server $connection -ViewType Datacenter -Property Name | Select Name,MoRef}
    Catch {DefaultErrorLogging -vCenter $vCenter -EnhancedLogging  $EnhancedLogging}

    If (!$VMdatacenters){
	    Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	    Catch {DefaultErrorLogging -vCenter $vCenter}
	    ExitPrematurely ("No Datacenters found in vCenter " + $vCenter)
    }

    ForEach ($VMdatacenter in $VMdatacenters){

	    #Datacenter Obj
	    $VMdatacenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datacenter']$")
	    $VMdatacenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.Datacenter']/DatacenterName$", $VMdatacenter.Name)
	    $VMdatacenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.Datacenter']/DatacenterId$", [string]($VMdatacenter.MoRef))
	    $VMdatacenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
	    $VMdatacenterObj.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $VMdatacenter.Name)
	    $discoveryData.AddInstance($VMdatacenterObj)
	
	    #vCenter Obj (already discovered)
	    $vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	    $vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	    #vCenter Hosts Datacenter
	    $rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsDatacenter']$")
	    $rel1.Source = $vCenterObj
	    $rel1.Target = $VMdatacenterObj
	    $discoveryData.AddInstance($rel1)
    }

    $date=Get-Date
    do {
        Try {
		    Disconnect-VIServer -Server $connection -Confirm:$false  

	    } Catch {
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    #DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 10
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}
$discoveryData
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Datastore" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.Datastore" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsDatastore" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:20</SyncTime>
          <ScriptName>Community.VMware.Discovery.Datastore.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.Datastore.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source ID: $sourceId, M anaged Entity Id:$managedEntityId,   vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
    $vCenterServerName=($a.content.vCenterServerNames).split(",")
}else{$vCenter=$vCenterServerName}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }




Function ExitPrematurely ($Message) {
	do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
   
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter"  | Out-File $EnhancedLoggingPath -append}
}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		ExitPrematurely("Unable to load VMware module")
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Connecting to vCenter Server: $vCenter" | Out-File $EnhancedLoggingPath -append  }

$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {$VMDatastores = Get-View -Server $connection -ViewType Datastore -Property Name | Select Name,MoRef}
Catch {DefaultErrorLogging}

If (!$VMDatastores){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}

    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No Datastores found in vCenter: $vCenter" | Out-File $EnhancedLoggingPath -append  }
	ExitPrematurely ("No Datastores found in vCenter " + $vCenter)
}

ForEach ($VMDatastore in $VMDatastores){

    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VMD atastore: $VMDatastore" | Out-File $EnhancedLoggingPath -append  }

	#Datastore Obj
	$VMDatastoreObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datastore']$")
	$VMDatastoreObj.AddProperty("$MPElement[Name='Community.VMware.Class.Datastore']/DatastoreName$", $VMDatastore.Name )
	$VMDatastoreObj.AddProperty("$MPElement[Name='Community.VMware.Class.Datastore']/DatastoreId$", ([string]$VMDatastore.MoRef))
	$VMDatastoreObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
	$VMDatastoreObj.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $VMDatastore.Name )
	$discoveryData.AddInstance($VMDatastoreObj)
	
	#vCenter Obj (already discovered)
	$vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	$vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	#vCenter Hosts Datastore
	$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsDatastore']$")
	$rel1.Source = $vCenterObj
	$rel1.Target = $VMDatastoreObj
	$discoveryData.AddInstance($rel1)
}

$date=Get-Date

do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Group.AllObjects" Target="Community.VMware.Class.Group.AllObjects" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$Target/Id$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Cluster"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Datacenter"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Datastore"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Network"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Datacenter"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.vApp"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.vCenter"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.vCenterServerService"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.VirtualMachine"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Group.ClustersWithoutHA" Target="Community.VMware.Class.Group.ClustersWithoutHA" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$Target/Id$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Cluster"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <Property>$MPElement[Name="Community.VMware.Class.Cluster"]/HAEnabled$</Property>
                  </ValueExpression>
                  <Operator>NotEqual</Operator>
                  <ValueExpression>
                    <Value>True</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Group.Rollup.vCenter" Target="Community.VMware.Class.Group.Rollup.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$Target/Id$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Community.VMware.Class.Rollup.vCenter"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Host" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.Host" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsHost" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:10</SyncTime>
          <ScriptName>Community.VMware.Discovery.Host.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.Host.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
    $vCenterServerName=($a.content.vCenterServerNames).split(",")
}else{$vCenter=$vCenterServerName}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

foreach($vCenter in $vCenterServerName | Where-Object {$_ -ne $null -and $_ -ne ""}){

    $date=Get-Date
    if($vCenter -ne $null -and $vcenter -ne ""){
    
        do {
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
            $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
            if($connection.IsConnected -ne $true){
                if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	            DefaultErrorLogging -vCenter $vCenter
                #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	            Start-Sleep -Seconds 10
            
   	        }
            $Now=Get-Date
        }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
            DefaultErrorLogging -vCenter $vCenter
            ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
        }Else{
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        }
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

        ExitPrematurely ("No vCenter Server Name passes, Exiting")
    }



    Try {
        $VMhosts = Get-View -Server $connection -ViewType HostSystem -Property Name,Parent | Select Name,Parent,MoRef
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Hosts: $VMhosts " | Out-File $EnhancedLoggingPath -append   }
    }
    Catch {DefaultErrorLogging -vCenter $vCenter}

    If (!$VMhosts){
	    Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	    Catch {DefaultErrorLogging -vCenter $vCenter}
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No Hosts found in vCenter " + $vCenter | Out-File $EnhancedLoggingPath -append   }
	    ExitPrematurely ("No Hosts found in vCenter " + $vCenter)
    
    }

    ForEach ($VMhost in $VMhosts){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$VM Host: $VMHost"| Out-File $EnhancedLoggingPath -append   }
	    If ($VMhost.Parent.Type -eq 'ClusterComputeResource'){
		    $IsStandalone = 'False'
	    }
	    Else {$IsStandalone = 'True'}

	    #Host Obj
	    $VMhostObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
	    $VMhostObj.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostName$", $VMhost.Name)
	    $VMhostObj.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]($VMhost.MoRef))
	    $VMhostObj.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/IsStandalone$", $IsStandalone)
	    $VMhostObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
	    $VMhostObj.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $VMhost.Name)
	    $discoveryData.AddInstance($VMhostObj)
	
	    #vCenter Obj (already discovered)
	    $vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	    $vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	    #vCenter Hosts Host
	    $rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsHost']$")
	    $rel1.Source = $vCenterObj
	    $rel1.Target = $VMhostObj
	    $discoveryData.AddInstance($rel1)
    }
    
    $date=Get-Date
    do {
	    Disconnect-VIServer -Server $connection -Confirm:$false  
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 10
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }

}
$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.HostDatastoreReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.HostReferencesDatastore" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>7200</IntervalSeconds>
          <SyncTime>01:15</SyncTime>
          <ScriptName>Community.VMware.Discovery.HostDatastoreReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.HostDatastoreReferenceDiscovery.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#} else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	
	#Append Logs
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append}

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

    


#Get Already Discovered Datastores from SCOM
Try {
    $VMdatastoreObjs = Get-SCOMClass -Name 'Community.VMware.Class.Datastore' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}
        
    Try{if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datastore Objs: $VMdatastoreObjs " | Out-File $EnhancedLoggingPath -append   } }
    Catch{
        Start-Sleep -Seconds 10
        Try{if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datastore Objs: $VMdatastoreObjs " | Out-File $EnhancedLoggingPath -append   } }
        Catch{DefaultErrorLogging -vCenter $vCenter}
        }
}

Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMdatastoreObjs){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "No VM Datastores found discovered in SCOM for vCenter " + $vCenter | Out-File $EnhancedLoggingPath -append   }
	#ExitPrematurely ("No VM Datastores found discovered in SCOM for vCenter " + $vCenter)
}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter
		ExitPrematurely ("Unable to Import VMware module")
	}
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


Try {$VMwareHosts = (Get-View -Server $connection -ViewType HostSystem -Property Datastore) | Select Datastore,MoRef}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareHosts){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "No VMs found in vCenter " + $vCenter| Out-File $EnhancedLoggingPath -append   }
	#ExitPrematurely ("No VMs found in vCenter " + $vCenter)
}

ForEach ($VMhost in $VMwareHosts){

	If ($VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VMhost.MoRef}){

		#VM Host Obj (already discovered)
		$VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
		$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$VMhost.MoRef )
		$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
		ForEach ($VMdatastore in $VMhost.Datastore){

			$MatchingDatastore = $VMdatastoreObjs | Where {$_.'[Community.VMware.Class.Datastore].DatastoreId'.Value -eq [string]$VMdatastore}
			If ($MatchingDatastore){

				#Datastore Obj (already discovered)
				$VMdatastoreInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datastore']$")
				$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datastore']/DatastoreId$", [string]$MatchingDatastore.'[Community.VMware.Class.Datastore].DatastoreId'.Value )
				$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
				
				#VM references Datastore
				$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.HostReferencesDatastore']$")
				$rel1.Source = $VMhostInstance
				$rel1.Target = $VMdatastoreInstance
				$discoveryData.AddInstance($rel1)
			}
		}
	}
}
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.HostNetworkReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.HostReferencesNetwork" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>7200</IntervalSeconds>
          <SyncTime>01:20</SyncTime>
          <ScriptName>Community.VMware.Discovery.HostNetworkReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.HostNetworkReference.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$a=parseIniFile -Inputfile C:\vCenter\vCenter.ini
$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#

vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Appen Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

#Get Already Discovered Networks from SCOM
Try {$VMnetworkObjs = Get-SCOMClass -Name 'Community.VMware.Class.Network' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMnetworkObjs){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No VM Networks found discovered in SCOM for vCenter " + $vCenter | Out-File $EnhancedLoggingPath -append   }

	ExitPrematurely ("No VM Networks found discovered in SCOM for vCenter " + $vCenter)
}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter
		Exit
	}
}

Try {
	$connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
} Catch {
	Start-Sleep -Seconds 10
	Try {
		$connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
	} Catch {
		DefaultErrorLogging -vCenter $vCenter
	}
}

If ($connection.IsConnected -ne $True){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter server " + $vCenter| Out-File $EnhancedLoggingPath -append   }

	ExitPrematurely ("Unable to connect to vCenter server " + $vCenter)
}

Try {$VMwareHosts = (Get-View -Server $connection -ViewType HostSystem -Property Network) | Select Network,MoRef}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareHosts){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No VMs found in vCenter " + $vCenter | Out-File $EnhancedLoggingPath -append   }

	ExitPrematurely ("No VMs found in vCenter " + $vCenter)
}

ForEach ($VMhost in $VMwareHosts){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: $VMHost"  | Out-File $EnhancedLoggingPath -append   }
	If ($VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VMhost.MoRef}){
            
		#VM Host Obj (already discovered)
		$VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
		$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$VMhost.MoRef )
		$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
		ForEach ($VMnetwork in $VMhost.Network){
			$MatchingNetwork = $VMnetworkObjs | Where {$_.'[Community.VMware.Class.Network].NetworkId'.Value -eq [string]$VMnetwork}
			If ($MatchingNetwork){
			    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"     Matching Network: $VMnetwork"  | Out-File $EnhancedLoggingPath -append   }
				#Network Obj (already discovered)
				$VMnetworkInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Network']$")
				$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Network']/NetworkId$", [string]$MatchingNetwork.'[Community.VMware.Class.Network].NetworkId'.Value )
				$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
				
				#VM references Network
				$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.HostReferencesNetwork']$")
				$rel1.Source = $VMhostInstance
				$rel1.Target = $VMnetworkInstance
				$discoveryData.AddInstance($rel1)
			}
		}
	}
}
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.HostDatacenterReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.HostReferencesDatacenter" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>21600</IntervalSeconds>
          <SyncTime>01:25</SyncTime>
          <ScriptName>Community.VMware.Discovery.HostDatacenterReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.HostDatacenterReference.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $SourceID,  Managed Entity Id: $managedEntityId,  vCenterServerName: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	
	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }
}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging -vCenter $vCenter}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging -vCenter $vCenter}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging -vCenter $vCenter}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}


$ExistingConnection=$null
$date=Get-Date

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter
		ExitPrematurely ("Unable to import VMware module")
	}
}

    
$ExistingConnection=$null
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {
        
    $VMwareDatacenters = Get-Datacenter -Server $connection
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datacenters: " + $VMwareDatacenters| Out-File $EnhancedLoggingPath -append   }
}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareDatacenters){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	#ExitPrematurely ("No VM Datacenters found in vCenter " + $vCenter)
}

ForEach ($VMdatacenter in $VMwareDatacenters){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datacenter: " + $VMwareDatacenter| Out-File $EnhancedLoggingPath -append   }

	#Verify VMdatacenter is in SCOM
	If ($VMdatacenterObjs | Where {$_.'[Community.VMware.Class.Datacenter].DatacenterId'.Value -eq [string]$VMdatacenter.Id}){
            
		#Get VMhosts in this datacenter
		Try {
            $VMhostsInDatacenter = $VMdatacenter | Get-VMHost | Get-View -Property Name | Select Name,MoRef

        }
		Catch {DefaultErrorLogging -vCenter $vCenter}

		If ($VMhostsInDatacenter){
		    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: $VMhostsInDatacenter  in Datacenter: " + $VMdatacenter| Out-File $EnhancedLoggingPath -append   }

			#VM datacenter Obj (already discovered)
			$VMdatacenterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datacenter']$")
			$VMdatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datacenter']/DatacenterId$", [string]$VMdatacenter.Id )
			$VMdatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
			ForEach ($VMhost in $VMhostsInDatacenter){
			
				#Verify Host is in SCOM
				If ($VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VMhost.MoRef}){
                    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Host: " + $VMhost| Out-File $EnhancedLoggingPath -append   }
					#VM Host Obj (already discovered)
					$VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
					$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$VMhost.MoRef )
					$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
					
					#Host references Datacenter
					$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.HostReferencesDatacenter']$")
					$rel1.Source = $VMhostInstance
					$rel1.Target = $VMdatacenterInstance
					$discoveryData.AddInstance($rel1)
				}
			}
		}
	}
}
$date=Get-Date

do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)



if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Network" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.Network" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsNetwork" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:25</SyncTime>
          <ScriptName>Community.VMware.Discovery.Network.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.Network.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}



$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-file $EnhancedLoggingPath -Append}

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

    
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {$VMnetworks = Get-View -Server $connection -ViewType Network -Property Name | Select Name,MoRef}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMnetworks){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No networks found in vCenter " + $vCenter)
}

ForEach ($VMnetwork in $VMnetworks){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") { "VM network: " + $VMnetwork | Out-File $EnhancedLoggingPath -append }

	#Network Obj
	$VMnetworkObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Network']$")
	$VMnetworkObj.AddProperty("$MPElement[Name='Community.VMware.Class.Network']/NetworkName$", $VMnetwork.Name)
	$VMnetworkObj.AddProperty("$MPElement[Name='Community.VMware.Class.Network']/NetworkId$", [string]($VMnetwork.MoRef))
	$VMnetworkObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
	$VMnetworkObj.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $VMnetwork.Name)
	$discoveryData.AddInstance($VMnetworkObj)
	
	#vCenter Obj (already discovered)
	$vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	$vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	#vCenter networks Network
	$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsNetwork']$")
	$rel1.Source = $vCenterObj
	$rel1.Target = $VMnetworkObj
	$discoveryData.AddInstance($rel1)
}


$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.Rollup.HostsAndClusters" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes />
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider">
          <IntervalSeconds>7200</IntervalSeconds>
          <SyncTime>02:00</SyncTime>
          <ScriptName>Community.VMware.Discovery.RollupHostsAndClusters.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.Rollup.HostsAndClusters.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenter" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging ($vCenter) {
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Appned Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter" + $vCenter   | Out-File $EnhancedLoggingPath -append   }
#Get Already Discovered Datacenters from this vCenter
Try {$VMdatacenterObjs = Get-SCOMClass -Name 'Community.VMware.Class.Datacenter' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMdatacenterObjs){
	ExitPrematurely ("No VM Datacenters found discovered in SCOM for vCenter " + $vCenter)
}

#Get Already Discovered Cluster Objects from this vCenter
Try {$DiscoveredClusters = Get-SCOMClass -Name 'Community.VMware.Class.Cluster' | Get-SCOMClassInstance  | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

#Get Already Discovered Standalone Hosts from this vCenter
Try {$DiscoveredStandaloneHosts = Get-SCOMClass -Name 'Community.VMware.Class.Host' | Get-SCOMClassInstance  | Where {($_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter) -and ($_.'[Community.VMware.Class.Host].IsStandalone'.Value -eq 'True')}}
Catch {DefaultErrorLogging -vCenter $vCenter}

#Create RollupvCenter Object
$vCenterRootInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']$")
$vCenterRootInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
$vCenterRootInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $vCenter)
$discoveryData.AddInstance($vCenterRootInstance)

#Create RollupHostsAndClusters for THIS RollupvCenter instance
$RollupHostsAndClustersInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']$")
$RollupHostsAndClustersInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", 'Hosts and Clusters')
$RollupHostsAndClustersInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
$RollupHostsAndClustersInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Hosts and Clusters')
$discoveryData.AddInstance($RollupHostsAndClustersInstance)

#RollupvCenterRoot Hosts RollupHostsAndClusters
$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.vCenterHostsHostsAndClusters']$")
$rel1.Source = $vCenterRootInstance
$rel1.Target = $RollupHostsAndClustersInstance
$discoveryData.AddInstance($rel1)

ForEach ($VMdatacenter in $VMdatacenterObjs){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM Datacenter " + $VMdatacenter   | Out-File $EnhancedLoggingPath -append   }
	#Create RollupDatacenter Obj
	$RollupDatacenterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']$")
	$RollupDatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterName$", $VMdatacenter.DisplayName)
	$RollupDatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
	$RollupDatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
	$RollupDatacenterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
	$RollupDatacenterInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$",  $VMdatacenter.DisplayName)
	$discoveryData.AddInstance($RollupDatacenterInstance)
	
	#RollupHostsAndClusters Hosts Datacenter
	$rel2 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClustersHostsDatacenter']$")
	$rel2.Source = $RollupHostsAndClustersInstance
	$rel2.Target = $RollupDatacenterInstance
	$discoveryData.AddInstance($rel2)
	
	#Create RollupAllClusters Obj
	$RollupAllClustersInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']$")
	$RollupAllClustersInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']/Name$", 'Clusters')
	$RollupAllClustersInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
	$RollupAllClustersInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
	$RollupAllClustersInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
	$RollupAllClustersInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Clusters')
	$discoveryData.AddInstance($RollupAllClustersInstance)
	
	#RollupDatacenter Hosts RollupAllClusters
	$rel3 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllClusters']$")
	$rel3.Source = $RollupDatacenterInstance
	$rel3.Target = $RollupAllClustersInstance
	$discoveryData.AddInstance($rel3)
	
	If ($DiscoveredClusters){
	
		#Get Discovered Cluster Objects in this Datacenter
		Try {$RelClusterReferencesDatacenter = Get-SCOMRelationship -Name 'Community.VMware.Relationship.ClusterReferencesDatacenter'}
		Catch {DefaultErrorLogging -vCenter $vCenter}
		
		Try {$DiscoveredClustersInThisDatacenter = Get-SCOMRelationshipInstance -TargetInstance $VMdatacenter | Where {$_.RelationshipId  -eq $RelClusterReferencesDatacenter.Id} | Select SourceObject}
		Catch {DefaultErrorLogging -vCenter $vCenter}

		ForEach ($Cluster in $DiscoveredClustersInThisDatacenter){
		    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Dicovered Cluster: " + $Cluster   | Out-File $EnhancedLoggingPath -append   }
			#Create RollupCluster Obj
			$RollupClusterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']$")
			$RollupClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']/ClusterName$", [string]$Cluster.SourceObject )
			$RollupClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']/ClusterId$", $Cluster.SourceObject.Name )
			$RollupClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']/Name$", 'Clusters')
			$RollupClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
			$RollupClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
			$RollupClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
			$RollupClusterInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", [string]$Cluster.SourceObject)
			$discoveryData.AddInstance($RollupClusterInstance)
			
			#RollupAllClusters Hosts RollupCluster
			$rel4 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.AllClustersHostsCluster']$")
			$rel4.Source = $RollupAllClustersInstance
			$rel4.Target = $RollupClusterInstance
			$discoveryData.AddInstance($rel4)
			
			#Already Discovered Cluster
			$ClusterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Cluster']$")
			$ClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/ClusterId$", [string]$Cluster.SourceObject.Name)
			$ClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
			
			#RollupCluster Contains Cluster
			$rel5 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterContainsCluster']$")
			$rel5.Source = $RollupClusterInstance
			$rel5.Target = $ClusterInstance
			$discoveryData.AddInstance($rel5)
			
			#Get Discovered Hosts In This Cluster
			$RelClusterContainsHost = Get-SCOMRelationship -Name 'Community.VMware.Relationship.ClusterContainsHost'
			$DiscoveredHostsInThisCluster = Get-SCOMRelationshipInstance -SourceInstance $Cluster.SourceObject | Where {$_.RelationshipId  -eq $RelClusterContainsHost.Id} | Select TargetObject
			
			ForEach ($DiscoveredHostInThisCluster in $DiscoveredHostsInThisCluster){
				
				#Get Virtual Machines in this Cluster Host
				$RelVirtualMachineReferencesHost = Get-SCOMRelationship -Name 'Community.VMware.Relationship.VirtualMachineReferencesHost'
				$VirtualMachinesInThisClusterHost = Get-SCOMRelationshipInstance -TargetInstance $DiscoveredHostInThisCluster.TargetObject | Where {$_.RelationshipId  -eq $RelVirtualMachineReferencesHost.Id} | Select SourceObject
				
				If ($VirtualMachinesInThisClusterHost){
				
					#Create RollupClusterVirtualMachines Instance
					$RollupClusterVirtualMachinesInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines']$")
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines']/Name$", 'Virtual Machines')
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']/ClusterId$", $Cluster.SourceObject.Name )
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']/Name$", 'Clusters')
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
					$RollupClusterVirtualMachinesInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Virtual Machines')
					$discoveryData.AddInstance($RollupClusterVirtualMachinesInstance)
								
					#RollupCluster Hosts RollupClusterVirtualMachines
					$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsVirtualMachines']$")
					$rel6.Source = $RollupClusterInstance
					$rel6.Target = $RollupClusterVirtualMachinesInstance
					$discoveryData.AddInstance($rel6)
					
					#Add VM Object to VM Rollup
					ForEach ($VirtualMachineInThisClusterHost in $VirtualMachinesInThisClusterHost){
					
						#Already Discovered VM
						$VMinstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
						$VMinstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", $VirtualMachineInThisClusterHost.SourceObject.Name )
						$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
						
						#RollupClusterVirtualMachines Contains VM
						$rel7 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterVirtualMachinesContainsVirtualMachine']$")
						$rel7.Source = $RollupClusterVirtualMachinesInstance
						$rel7.Target = $VMinstance
						$discoveryData.AddInstance($rel7)
					}
				}
			
				#Get Datastores in this Cluster Host
				$RelHostReferencesDatastore = Get-SCOMRelationship -Name 'Community.VMware.Relationship.HostReferencesDatastore'
				$VMdatastoresInThisClusterHost = Get-SCOMRelationshipInstance -SourceInstance $DiscoveredHostInThisCluster.TargetObject | Where {$_.RelationshipId  -eq $RelHostReferencesDatastore.Id} | Select TargetObject
				
				If ($VMdatastoresInThisClusterHost){
					
					#Create RollupDatastore
					$RollupClusterDatastoreInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores']$")
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores']/Name$", 'Datastores')
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']/ClusterId$", $Cluster.SourceObject.Name )
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']/Name$", 'Clusters')
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
					$RollupClusterDatastoreInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Datastores')
					$discoveryData.AddInstance($RollupClusterDatastoreInstance)
								
					#RollupCluster Hosts RollupClusterDatastores
					$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsDatastores']$")
					$rel6.Source = $RollupClusterInstance
					$rel6.Target = $RollupClusterDatastoreInstance
					$discoveryData.AddInstance($rel6)
					
					ForEach ($VMdatastoreInThisClusterHost in $VMdatastoresInThisClusterHost){
					
						#Already Discovered Datastore Obj
						$VMdatastoreInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datastore']$")
						$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datastore']/DatastoreId$", $VMdatastoreInThisClusterHost.TargetObject.Name )
						$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
						
						#RollupClusterDatastores Contains VM
						$rel7 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterDatastoresContainsDatastore']$")
						$rel7.Source = $RollupClusterDatastoreInstance
						$rel7.Target = $VMdatastoreInstance
						$discoveryData.AddInstance($rel7)
					}
				}
				
				#Get Networks in this Cluster Host
				$RelHostReferencesNetwork = Get-SCOMRelationship -Name 'Community.VMware.Relationship.HostReferencesNetwork'
				$NetworksInThisClusterHost = Get-SCOMRelationshipInstance -SourceInstance $DiscoveredHostInThisCluster.TargetObject | Where {$_.RelationshipId  -eq $RelHostReferencesNetwork.Id} | Select TargetObject
				
				If ($NetworksInThisClusterHost){
					
					#Create RollupNetwork
					$RollupClusterNetworkInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks']$")
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks']/Name$", 'Networks')
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']/ClusterId$", $Cluster.SourceObject.Name )
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']/Name$", 'Clusters')
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
					$RollupClusterNetworkInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Networks')
					$discoveryData.AddInstance($RollupClusterNetworkInstance)
								
					#RollupCluster Hosts RollupNetwork
					$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsNetworks']$")
					$rel6.Source = $RollupClusterInstance
					$rel6.Target = $RollupClusterNetworkInstance
					$discoveryData.AddInstance($rel6)
					
					ForEach ($NetworkInThisClusterHost in $NetworksInThisClusterHost){
					
						#Already Discovered Network Obj
						$VMnetworkInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Network']$")
						$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Network']/NetworkId$", $NetworkInThisClusterHost.TargetObject.Name)
						$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
						
						#RollupClusterDatastores Contains VM
						$rel7 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterNetworksContainsNetwork']$")
						$rel7.Source = $RollupClusterNetworkInstance
						$rel7.Target = $VMnetworkInstance
						$discoveryData.AddInstance($rel7)
					}
				}
			}
		
			#Get Discovered vApps In this Cluster
			$RelvAppReferencesCluster = Get-SCOMRelationship -Name 'Community.VMware.Relationship.vAppReferencesCluster'
			$DiscoveredvAppsReferencingCluster = Get-SCOMRelationshipInstance -TargetInstance $Cluster.SourceObject | Where {$_.RelationshipId  -eq $RelvAppReferencesCluster.Id} | Select SourceObject
			
			If ($DiscoveredvAppsReferencingCluster){
			
				#Create RollupClustervApps Instance
				$RollupvAppsInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps']$")
				$RollupvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps']/Name$", 'vApps')
				$RollupvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Cluster']/ClusterId$", $Cluster.SourceObject.Name )
				$RollupvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllClusters']/Name$", 'Clusters')
				$RollupvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
				$RollupvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
				$RollupvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
				$RollupvAppsInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'vApps')
				$discoveryData.AddInstance($RollupvAppsInstance)
							
				#RollupCluster Hosts RollupClustervApps
				$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsvApps']$")
				$rel6.Source = $RollupClusterInstance
				$rel6.Target = $RollupvAppsInstance
				$discoveryData.AddInstance($rel6)
			
				ForEach ($DiscoveredvAppReferencingCluster in $DiscoveredvAppsReferencingCluster){
				
					#Already Discovered vApp
					$vAppInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vApp']$")
					$vAppInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vApp']/vAppId$", $DiscoveredvAppReferencingCluster.SourceObject.Name )
					$vAppInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
					
					#RollupClustervApps Contains vApps
					$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.ClustervAppsContainsvApp']$")
					$rel6.Source = $RollupvAppsInstance
					$rel6.Target = $vAppInstance
					$discoveryData.AddInstance($rel6)
				}
			}
		}
	}

	#Create AllStandaloneHosts Obj
	$RollupAllStandaloneHostsInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']$")
	$RollupAllStandaloneHostsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']/Name$", 'Standalone Hosts')
	$RollupAllStandaloneHostsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
	$RollupAllStandaloneHostsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", 'Hosts and Clusters')
	$RollupAllStandaloneHostsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
	$RollupAllStandaloneHostsInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Standalone Hosts')
	$discoveryData.AddInstance($RollupAllStandaloneHostsInstance)
	
	#RollupDatacenter Hosts AllStandaloneHosts
	$rel8 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllStandaloneHosts']$")
	$rel8.Source = $RollupDatacenterInstance
	$rel8.Target = $RollupAllStandaloneHostsInstance
	$discoveryData.AddInstance($rel8)
	
	If ($DiscoveredStandaloneHosts){
	
		#Get Discovered Standalone Hosts in this Datacenter
		$RelHostReferencesDatacenter = Get-SCOMRelationship -Name 'Community.VMware.Relationship.HostReferencesDatacenter'
		$DiscoveredHostsInThisDatacenter = Get-SCOMRelationshipInstance -TargetInstance $VMdatacenter | Where {$_.RelationshipId  -eq $RelHostReferencesDatacenter.Id} | Select SourceObject
		
		ForEach ($DiscoveredHostInThisDatacenter in $DiscoveredHostsInThisDatacenter){
				    
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Discovered Stand alone Host: " + $DiscoveredHostInThisDatacenter   | Out-File $EnhancedLoggingPath -append }  
			    
			#Only Standalone Hosts
			If ($DiscoveredStandaloneHosts | Where {$_.Id -eq $DiscoveredHostInThisDatacenter.SourceObject.Id}){
				#Create RollupStandaloneHost Obj
				$RollupStandaloneHostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']$")
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']/HostName$", [string]$DiscoveredHostInThisDatacenter.SourceObject )
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']/HostId$", $DiscoveredHostInThisDatacenter.SourceObject.Name )
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']/Name$", 'Standalone Hosts')
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
				$RollupStandaloneHostInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", [string]$DiscoveredHostInThisDatacenter.SourceObject)
				$discoveryData.AddInstance($RollupStandaloneHostInstance)
				
				#RollupAllStandaloneHosts Hosts RollupStandaloneHost
				$rel9 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.AllStandaloneHostsHostsStandaloneHost']$")
				$rel9.Source = $RollupAllStandaloneHostsInstance
				$rel9.Target = $RollupStandaloneHostInstance
				$discoveryData.AddInstance($rel9)
				
				#Already Discovered Host Obj
				$VMhostObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
				$VMhostObj.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", $DiscoveredHostInThisDatacenter.SourceObject.Name)
				$VMhostObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
				
				#RollupStandaloneHost Contains Host
				$rel10 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostContainsHost']$")
				$rel10.Source = $RollupStandaloneHostInstance
				$rel10.Target = $VMhostObj
				$discoveryData.AddInstance($rel10)
				
				#VMs in Standalone Host
				$RelVirtualMachineReferencesHost = Get-SCOMRelationship -Name 'Community.VMware.Relationship.VirtualMachineReferencesHost'
				$VirtualMachinesInThisStandaloneHost = Get-SCOMRelationshipInstance -TargetInstance $DiscoveredHostInThisDatacenter.SourceObject | Where {$_.RelationshipId  -eq $RelVirtualMachineReferencesHost.Id} | Select SourceObject
				
				If ($VirtualMachinesInThisStandaloneHost){
				
					#Create RollupStandaloneHostVirtualMachines Instance
					$RollupStandaloneHostVirtualMachinesInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines']$")
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines']/Name$", 'Virtual Machines')
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']/HostId$", $DiscoveredHostInThisDatacenter.SourceObject.Name)
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']/Name$", 'Standalone Hosts')
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
					$RollupStandaloneHostVirtualMachinesInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Virtual Machines')
					$discoveryData.AddInstance($RollupStandaloneHostVirtualMachinesInstance)
								
					#RollupStandaloneHost Hosts RollupStandaloneHostVirtualMachines
					$rel11 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsVirtualMachines']$")
					$rel11.Source = $RollupStandaloneHostInstance
					$rel11.Target = $RollupStandaloneHostVirtualMachinesInstance
					$discoveryData.AddInstance($rel11)
					
					#Add VM Object to VM Rollup
					ForEach ($VirtualMachineInThisStandaloneHost in $VirtualMachinesInThisStandaloneHost){
					    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Virtual Machine In This Standalone Host ($DiscoveredHostInThisDatacenter):" + $VirtualMachineInThisStandaloneHost   | Out-File $EnhancedLoggingPath -append }
						#Already Discovered VM
						$VMinstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
						$VMinstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", $VirtualMachineInThisStandaloneHost.SourceObject.Name )
						$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
						
						#RollupStandaloneHostVirtualMachines Contains VM
						$rel12 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesContainsVirtualMachine']$")
						$rel12.Source = $RollupStandaloneHostVirtualMachinesInstance
						$rel12.Target = $VMinstance
						$discoveryData.AddInstance($rel12)
					}
				}
			
				#Get Datastores in this Standalone Host
				$RelHostReferencesDatastore = Get-SCOMRelationship -Name 'Community.VMware.Relationship.HostReferencesDatastore'
				$VMdatastoresInThisStandaloneHost = Get-SCOMRelationshipInstance -SourceInstance $DiscoveredHostInThisDatacenter.SourceObject | Where {$_.RelationshipId  -eq $RelHostReferencesDatastore.Id} | Select TargetObject
				
				If ($VMdatastoresInThisStandaloneHost){
					
					#Create RollupDatastore
					$RollupStandaloneHostDatastoresInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores']$")
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores']/Name$", 'Datastores')
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']/HostId$", $DiscoveredHostInThisDatacenter.SourceObject.Name)
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']/Name$", 'Standalone Hosts')
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
					$RollupStandaloneHostDatastoresInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Datastores')
					$discoveryData.AddInstance($RollupStandaloneHostDatastoresInstance)
					
					#RollupStandaloneHost Contains RollupDatastore
					$rel11 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsDatastores']$")
					$rel11.Source = $RollupStandaloneHostInstance
					$rel11.Target = $RollupStandaloneHostDatastoresInstance
					$discoveryData.AddInstance($rel11)
					
					ForEach ($VMdatastoreInThisStandaloneHost in $VMdatastoresInThisStandaloneHost){
						if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"VM datastore In This Standalone Host: " + $VMdatastoreInThisStandaloneHost   | Out-File $EnhancedLoggingPath -append }

						#Already Discovered Datastore Obj
						$VMdatastoreInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datastore']$")
						$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datastore']/DatastoreId$", $VMdatastoreInThisStandaloneHost.TargetObject.Name )
						$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
						
						#RollupDatastore Contains Datastore
						$rel12 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostDatastoresContainsDatastore']$")
						$rel12.Source = $RollupStandaloneHostDatastoresInstance
						$rel12.Target = $VMdatastoreInstance
						$discoveryData.AddInstance($rel12)
					}
				}
				
				#Get Networks in this Standalone Host
				$RelHostReferencesNetwork = Get-SCOMRelationship -Name 'Community.VMware.Relationship.HostReferencesNetwork'
				$NetworksInThisStandaloneHost = Get-SCOMRelationshipInstance -SourceInstance $DiscoveredHostInThisDatacenter.SourceObject | Where {$_.RelationshipId  -eq $RelHostReferencesNetwork.Id} | Select TargetObject
				
				If ($NetworksInThisStandaloneHost){
					
					#Create RollupNetwork
					$RollupStandaloneHostNetworksInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks']$")
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks']/Name$", 'Networks')
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']/HostId$", $DiscoveredHostInThisDatacenter.SourceObject.Name)
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']/Name$", 'Standalone Hosts')
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
					$RollupStandaloneHostNetworksInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'Networks')
					$discoveryData.AddInstance($RollupStandaloneHostNetworksInstance)
					
					#RollupStandaloneHost Contains RollupNetwork
					$rel11 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsNetworks']$")
					$rel11.Source = $RollupStandaloneHostInstance
					$rel11.Target = $RollupStandaloneHostNetworksInstance
					$discoveryData.AddInstance($rel11)
					
					ForEach ($NetworkInThisStandaloneHost in $NetworksInThisStandaloneHost){
					    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Network In This Stand alone Host: " + $NetworkInThisStandaloneHost   | Out-File $EnhancedLoggingPath -append }
						#Already Discovered Network Obj
						$VMnetworkInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Network']$")
						$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Network']/NetworkId$", $NetworkInThisStandaloneHost.TargetObject.Name )
						$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
						
						#RollupNetwork Contains Network
						$rel12 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostNetworksContainsNetwork']$")
						$rel12.Source = $RollupStandaloneHostNetworksInstance
						$rel12.Target = $VMnetworkInstance
						$discoveryData.AddInstance($rel12)
					}
				}
			}
				
			#Get Discovered vApps In this Host
			$RelvAppReferencesHost = Get-SCOMRelationship -Name 'Community.VMware.Relationship.vAppReferencesHost'
			$DiscoveredvAppsReferencingHost = Get-SCOMRelationshipInstance -TargetInstance $Host.SourceObject | Where {$_.RelationshipId  -eq $RelvAppReferencesHost.Id} | Select SourceObject
			
			If ($DiscoveredvAppsReferencingHost){
			
				#Create RollupHostvApps Instance
				$RollupStandaloneHostvAppsInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps']$")
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps']/Name$", 'vApps')
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost']/HostId$", $DiscoveredHostInThisDatacenter.SourceObject.Name)
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts']/Name$", 'Standalone Hosts')
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters.Datacenter']/DatacenterId$", $VMdatacenter.'[Community.VMware.Class.Datacenter].DatacenterId'.Value )
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.HostsAndClusters']/Name$", "Hosts and Clusters")
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Rollup.vCenter']/vCenterServerName$", $vCenter)
				$RollupStandaloneHostvAppsInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", 'vApps')
				$discoveryData.AddInstance($RollupStandaloneHostvAppsInstance)
							
				#RollupHost Hosts RollupHostvApps
				$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsvApps']$")
				$rel6.Source = $RollupStandaloneHostInstance
				$rel6.Target = $RollupStandaloneHostvAppsInstance
				$discoveryData.AddInstance($rel6)
			
				ForEach ($DiscoveredvAppReferencingHost in $DiscoveredvAppsReferencingHost){
				    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Discovered vApp Referencing Host: " + $DiscoveredvAppReferencingHost   | Out-File $EnhancedLoggingPath -append } 
					#Already Discovered vApp
					$vAppInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vApp']$")
					$vAppInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vApp']/vAppId$", $DiscoveredvAppReferencingHost.SourceObject.Name )
					$vAppInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
					
					#RollupHostvApps Contains vApps
					$rel6 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostvAppsContainsvApp']$")
					$rel6.Source = $RollupStandaloneHostvAppsInstance
					$rel6.Target = $vAppInstance
					$discoveryData.AddInstance($rel6)
				}
			}
		}
	}
}
$discoveryData
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.vApp" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.vApp" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsvApp" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:30</SyncTime>
          <ScriptName>Community.VMware.Discovery.vApp.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.vApp.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$CenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
    $vCenterServerName=($a.content.vCenterServerNames).split(",")
}else{$vCenter=$vCenterServerName}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }


 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)

	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName: $vCenter"  | Out-File $EnhancedLoggingPath -append   }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter: $vCenter "| Out-File $EnhancedLoggingPath -append   }

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}

Try {$VMvApps = Get-vApp -Server $connection | Select Name,Id}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMvApps){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No vApps found in vCenter " + $vCenter)
}

ForEach ($vApp in $VMvApps){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vApp Found: $vApp "| Out-File $EnhancedLoggingPath -append   }

	#vApp Obj
	$vAppObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vApp']$")
	$vAppObj.AddProperty("$MPElement[Name='Community.VMware.Class.vApp']/vAppName$", $vApp.Name )
	$vAppObj.AddProperty("$MPElement[Name='Community.VMware.Class.vApp']/vAppId$", $vApp.Id )
	$vAppObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter)
	$vAppObj.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $vApp.Name )
	$discoveryData.AddInstance($vAppObj)
	
	#vCenter Obj (already discovered)
	$vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	$vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	#vCenter Hosts vApp
	$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsvApp']$")
	$rel1.Source = $vCenterObj
	$rel1.Target = $vAppObj
	$discoveryData.AddInstance($rel1)
}
    
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.vAppHostAndClusterReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vAppReferencesCluster" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vAppReferencesHost" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>3600</IntervalSeconds>
          <SyncTime>01:45</SyncTime>
          <ScriptName>Community.VMware.Discovery.vAppHostAndClusterReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.vAppHostAndClusterReferenceRelationship.ps1'

$vCenter=$vCenterServerName

$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerName: $vCenter" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}


Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }


}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter: $vCenter "| Out-File $EnhancedLoggingPath -append   }

#Get Already Discovered vApps from SCOM
Try {$vAppObjs = Get-SCOMClass -Name 'Community.VMware.Class.vApp' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

#Exit if no VMs are discovered, because there is no relationship to build
If (!$vAppObjs){
	ExitPrematurely ("No vApps found discovered in SCOM for vCenter " + $vCenter)
}

#Get Already Discovered Clusters from SCOM
Try {$VMclusterObjs = Get-SCOMClass -Name 'Community.VMware.Class.Cluster' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

#Get Already Discovered Clusters from SCOM
Try {$VMhostObjs = Get-SCOMClass -Name 'Community.VMware.Class.Host' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 15
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter

		ExitPrematurely("Unable to load VMware module")
	}
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


Try {
    $VMwarevApps = Get-View -Server $connection -ViewType VirtualApp -Property Owner | Select Owner,MoRef
            
}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwarevApps){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vApps found "| Out-File $EnhancedLoggingPath -append   }
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No vApps found in vCenter " + $vCenter)
}

ForEach ($vApp in $VMwarevApps){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Found vApp: $vApp "| Out-File $EnhancedLoggingPath -append   }

	#Only move forward with already discovered vApps
	If ($vAppObjs | Where {$_.'[Community.VMware.Class.vApp].vAppId'.Value -eq [string]$vApp.MoRef}){
		
		$vAppInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vApp']$")
		$vAppInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vApp']/vAppId$", [string]$vApp.MoRef)
		$vAppInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
	
		If ($VMclusterObjs | Where {$_.'[Community.VMware.Class.Cluster].ClusterId'.Value -eq [string]$vApp.Owner}){
		
			$ClusterInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Cluster']$")
			$ClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Cluster']/ClusterId$", [string]$vApp.Owner )
			$ClusterInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
			
			#vApp reference Cluster
			$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vAppReferencesCluster']$")
			$rel1.Source = $vAppInstance
			$rel1.Target = $ClusterInstance
			$discoveryData.AddInstance($rel1)
		}
		ElseIf ($VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$vApp.Owner}){
				
			$HostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
			$HostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$vApp.Owner )
			$HostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

			#VM reference Host
			$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vAppReferencesHost']$")
			$rel1.Source = $vAppInstance
			$rel1.Target = $HostInstance
			$discoveryData.AddInstance($rel1)
		}
	}
}
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit
]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.vCenter" Target="Community.VMware.Class.ResourcePool" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.vCenter" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.ResourcePoolHostsvCenter" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider">
          <IntervalSeconds>7200</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <ScriptName>Community.VMware.Discovery.vCenter.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId)

$ScriptName = 'Community.VMware.Discovery.vCenterDiscovery.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#   $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

Function ExitPrematurely ($Message) {
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$ScriptName,1985,$EventLevel,$Message" | Out-File $EnhancedLoggingPath -append }
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}
 
Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel,		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenterServerName")

	#Appen Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenterServerName" | Out-File $EnhancedLoggingPath -append   }

}

$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection -ComputerName 'localhost'}
Catch {DefaultErrorLogging}

Try {$vCenterServerServices = Get-SCOMClass -Name 'Community.VMware.Class.vCenterServerService' | Get-SCOMClassInstance}
Catch {DefaultErrorLogging}

If (!$vCenterServerServices){

	$discoveryData.IsSnapshot = $false

}	Else {
	
	#VMware Monitoring Resource Pool Obj
	$Pool = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.ResourcePool']$")
	
	#Discover vCenter Instances
	
		$vCenterServer | out-file $EnhancedLoggingPath -appent
		#vCenter Obj
		$vCenter = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
		$vCenter.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", ($vCenterServer.'[Microsoft.Windows.Computer].PrincipalName'.Value))
		$vCenter.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", ($vCenterServer.'[Microsoft.Windows.Computer].PrincipalName'.Value))
		$discoveryData.AddInstance($vCenter)
		
		#Resource Pool Hosts vSphere
		$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.ResourcePoolHostsvCenter']$")
		$rel1.Source = $Pool
		$rel1.Target = $vCenter
		$discoveryData.AddInstance($rel1)
	
}

#Return Discovery Data
$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit
]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.vCenterServerService" Target="Windows!Microsoft.Windows.Server.Computer" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.vCenterServerService" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.Win32ServiceInformationProviderWithClassSnapshotDataMapper">
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>vpxd</ServiceName>
          <Frequency>7200</Frequency>
          <ClassId>$MPElement[Name="Community.VMware.Class.vCenterServerService"]$</ClassId>
          <InstanceSettings>
            <Settings>
              <Setting>
                <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                <Value>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="MSNL!Microsoft.SystemCenter.NTService"]/ServiceName$</Name>
                <Value>$Data/Property[@Name='Name']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="MSNL!Microsoft.SystemCenter.NTService"]/ServiceProcessName$</Name>
                <Value>$Data/Property[@Name='BinaryPathName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="MSNL!Microsoft.SystemCenter.NTService"]/DisplayName$</Name>
                <Value>$Data/Property[@Name='DisplayName']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="MSNL!Microsoft.SystemCenter.NTService"]/Description$</Name>
                <Value>$Data/Property[@Name='Description']$</Value>
              </Setting>
              <Setting>
                <Name>$MPElement[Name="System!System.Entity"]/DisplayName$</Name>
                <Value>$Data/Property[@Name='DisplayName']$</Value>
              </Setting>
            </Settings>
          </InstanceSettings>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.VirtualMachineDatastoreReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.VirtualMachineReferencesDatastore" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>7200</IntervalSeconds>
          <SyncTime>01:30</SyncTime>
          <ScriptName>Community.VMware.Discovery.VirtualMachineDatastoreReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.VirtualMachineDatastoreReferenceRelationship.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}

$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
    $vCenterServerName=($a.content.vCenterServerNames).split(",")
}else{$vCenter=$vCenterServerName}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }




 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter"| Out-File $EnhancedLoggingPath -append   }
    }



$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

#Get Already Discovered Virtual Machines from SCOM
Try {$VMobjs = Get-SCOMClass -Name 'Community.VMware.Class.VirtualMachine' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

#Exit if no VMs are discovered, because there is no relationship to build
If (!$VMobjs){
	ExitPrematurely ("No VMs found discovered in SCOM for vCenter " + $vCenter)
}

#Get Already Discovered Datastores from SCOM
Try {$VMdatastoreObjs = Get-SCOMClass -Name 'Community.VMware.Class.Datastore' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging -vCenter $vCenter}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging -vCenter $vCenter

		ExitPrematurely("Unable to import VMware module")
	}
}
$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


Try {$VMwareVirtualMachines = (Get-View -Server $connection -ViewType VirtualMachine -Property Summary,Datastore -Filter @{"Config.Template"="false"}) | Select Summary,Datastore}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareVirtualMachines){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No VMs found in vCenter " + $vCenter)
}

ForEach ($VM in $VMwareVirtualMachines){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Virtual Machine: $VM " | Out-File $EnhancedLoggingPath -append   }

	If ($VMobjs | Where {$_.'[Community.VMware.Class.VirtualMachine].VirtualMachineId'.Value -eq [string]$VM.Summary.Vm}){

		#Virtual Machine Obj (already discovered)
		$VMInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
		$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", [string]$VM.Summary.Vm )
		$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
		ForEach ($VMdatastore in $VM.Datastore){
			$MatchingDatastore = $VMdatastoreObjs | Where {$_.'[Community.VMware.Class.Datastore].DatastoreId'.Value -eq [string]$VMdatastore}
			If ($MatchingDatastore){
				if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"       Datastore:  $VMdatastore " | Out-File $EnhancedLoggingPath -append   }

				#VMdatastore Obj (already discovered)
				$VMdatastoreInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Datastore']$")
				$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Datastore']/DatastoreId$", [string]$MatchingDatastore.'[Community.VMware.Class.Datastore].DatastoreId'.Value )
				$VMdatastoreInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
				
				#VM reference Host
				$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.VirtualMachineReferencesDatastore']$")
				$rel1.Source = $VMInstance
				$rel1.Target = $VMdatastoreInstance
				$discoveryData.AddInstance($rel1)
			}
		}
	}
}
$date=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
    $Now=Get-Date
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.VirtualMachine" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Community.VMware.Class.VirtualMachine" />
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.vCenterHostsVirtualMachine" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>00:35</SyncTime>
          <ScriptName>Community.VMware.Discovery.VirtualMachine.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.VirtualMachines.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
$vCenter=$vCenterServerName
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    do {
        $connection=Get-VIServer -Server $vCenter -NotDefault 
	    Disconnect-VIServer -Server $connection -Confirm:$false
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 10
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit

}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

	#Append Logs 
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append  }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
		Exit
	}
}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter: $vCenter"| Out-File $EnhancedLoggingPath -append   }

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


Try {$VMwareVirtualMachines = (Get-View -Server $connection -ViewType VirtualMachine -Property Name,Summary -Filter @{"Config.Template"="false"}) | Select Name,Summary}
Catch {DefaultErrorLogging -vCenter $vCenter}

If (!$VMwareVirtualMachines){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging -vCenter $vCenter}
	ExitPrematurely ("No VMs found in vCenter " + $vCenter)
}

ForEach ($VM in $VMwareVirtualMachines){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Found VM: $VM"| Out-File $EnhancedLoggingPath -append   }
	#Virtual Machine Obj
	$VMInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
	$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineName$", [string]$VM.Name )
	$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineHostName$", [string]$VM.Summary.Guest.HostName )
	$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", [string]$VM.Summary.Vm )
	$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
	$VMInstance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$",  [string]$VM.Name )
	$discoveryData.AddInstance($VMInstance)
	
	#vCenter Obj (already discovered)
	$vCenterObj = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.vCenter']$")
	$vCenterObj.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )

	#vCenter Hosts Virtual Machine
	$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.vCenterHostsVirtualMachine']$")
	$rel1.Source = $vCenterObj
	$rel1.Target = $VMInstance
	$discoveryData.AddInstance($rel1)
}
$date=Get-Date
$Now=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
        
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}


$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.VirtualMachineComputerRelationship" Target="Community.VMware.Class.ResourcePool" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="SVL!System.VirtualMachineContainsComputer" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider">
          <IntervalSeconds>14400</IntervalSeconds>
          <SyncTime>01:40</SyncTime>
          <ScriptName>Community.VMware.Discovery.VirtualMachineComputerRelationship.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId)

$ScriptName = 'Community.VMware.Discovery.VirtualMachineComputerRelationship.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}


$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

if(($a -ne "WinvCenter") -and ($a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
    $vCenterServerName=($a.content.vCenterServerNames).split(",")
}else{$vCenter=$vCenterServerName}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenterServerName")
	
	#Append Logs
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenterServerName" | Out-File $EnhancedLoggingPath -append   }

}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

Try {$VMobjs = Get-SCOMClass -Name 'Community.VMware.Class.VirtualMachine' | Get-SCOMClassInstance}
Catch {DefaultErrorLogging}

Try {$ComputerObjs = Get-SCOMClass -Name 'System.Computer' | Get-SCOMClassInstance}
Catch {DefaultErrorLogging}

ForEach ($VM in $VMobjs){
	if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Found VM: $VM" | Out-File $EnhancedLoggingPath -append   }
	Try {$MatchingComputerObj = $ComputerObjs | Where {$_.DisplayName -eq ($VM.'[Community.VMware.Class.VirtualMachine].VirtualMachineHostName'.Value)}}
	Catch {DefaultErrorLogging}
	If ($MatchingComputerObj){

		#Get Computer Class Type
		Try {$ClassType = Get-SCOMClass -Id ($MatchingComputerObj.LeastDerivedNonAbstractMonitoringClassId) | Select Name}
		Catch {DefaultErrorLogging}
		
		#If a Winodows Computer
		If ($ClassType.Name -eq 'Microsoft.Windows.Computer'){

			#Create Windows Computer Object for discovery
			$WindowsInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Windows!Microsoft.Windows.Computer']$")
			$WindowsInstance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", [string]$MatchingComputerObj.'[Microsoft.Windows.Computer].PrincipalName'.Value )
			
			#Create Virtual Machine object for discovery
			$VMinstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
			$VMinstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", [string]$VM.'[Community.VMware.Class.VirtualMachine].VirtualMachineId'.Value )
			$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$",  [string]$VM.'[Community.VMware.Class.vCenter].vCenterServerName'.value )
			
			#Create Relationship (Virtual Machine Contains Computer)
			$rel1 =  $discoveryData.CreateRelationshipInstance("$MPElement[Name='SVL!System.VirtualMachineContainsComputer']$")
			$rel1.source = $VMinstance
			$rel1.target = $WindowsInstance
			$discoveryData.AddInstance($rel1)
		}
		ElseIf ($ClassType.Name -eq 'Microsoft.Unix.Computer'){

			#Create Unix Computer Object for discovery
			$WindowsInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Unix!Microsoft.Unix.Computer']$")
			$WindowsInstance.AddProperty("$MPElement[Name='Unix!Microsoft.Unix.Computer']/PrincipalName$", [string]$MatchingComputerObj.'[Microsoft.Unix.Computer].PrincipalName'.Value )
			
			#Create Virtual Machine object for discovery
			$VMinstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
			$VMinstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", [string]$VM.'[Community.VMware.Class.VirtualMachine].VirtualMachineId'.Value )
			$VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$",  [string]$VM.'[Community.VMware.Class.vCenter].vCenterServerName'.value )
			
			#Create Relationship (Virtual Machine Contains Computer)
			$rel1 =  $discoveryData.CreateRelationshipInstance("$MPElement[Name='SVL!System.VirtualMachineContainsComputer']$")
			$rel1.source = $VMinstance
			$rel1.target = $WindowsInstance
			$discoveryData.AddInstance($rel1)
		}
		     
		#Can't determine Computer Class Type
		Else {
			$api.LogScriptEvent($ScriptName,1985,2,('Unable to map '+ $MatchingComputerObj.DisplayName +' to class '+ $ClassType.Name))
		}
	}
}
$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit
]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.VirtualMachineHostReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.VirtualMachineReferencesHost" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>3600</IntervalSeconds>
          <SyncTime>01:45</SyncTime>
          <ScriptName>Community.VMware.Discovery.VirtualMachineHostReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.VirtualMachineHostReference.ps1'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

 
$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#

$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    ddo {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenterServerName")

    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenterServerName" | Out-File $EnhancedLoggingPath -append   }
}

$api = new-object -comObject 'MOM.ScriptAPI'
$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

#Get Already Discovered Virtual Machines from SCOM
Try {$VMobjs = Get-SCOMClass -Name 'Community.VMware.Class.VirtualMachine' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenterServerName}}
Catch {DefaultErrorLogging}

#Exit if no VMs are discovered, because there is no relationship to build
If (!$VMobjs){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No VMs found discovered in SCOM for vCenter " + $vCenterServerName | Out-File $EnhancedLoggingPath -append   }
	ExitPrematurely ("No VMs found discovered in SCOM for vCenter " + $vCenterServerName)
}

#Get Already Discovered VMhosts
Try {$VMhostObjs	= Get-SCOMClass -Name 'Community.VMware.Class.Host' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenterServerName}}
Catch {DefaultErrorLogging}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging

		ExitPrematurely("Unable to Import VMware Module")
	}
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


    Try {$VMwareVirtualMachines = (Get-View -Server $connection -ViewType VirtualMachine -Property Name,Runtime,Summary -Filter @{"Config.Template"="false"}) | Select Name,Runtime,Summary}
    Catch {DefaultErrorLogging}

    If (!$VMwareVirtualMachines){
	    Try {
            Disconnect-VIServer -Server $connection -Confirm:$false
        
        }
        Catch {
            Start-Sleep -Seconds 10
            Try{
                Disconnect-VIServer -Server $connection -Confirm:$false
            }
            Catch{
                DefaultErrorLogging -vCenter $vCenter
            }
        }
	    ExitPrematurely ("No VMs found in vCenter " + $vCenter)
    }

    ForEach ($VM in $VMwareVirtualMachines){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Virtual Machine $VM" | Out-File $EnhancedLoggingPath -append   }

	    If ($VMobjs | Where {$_.'[Community.VMware.Class.VirtualMachine].VirtualMachineId'.Value -eq [string]$VM.Summary.Vm}){

		    #Virtual Machine Obj (already discovered)
		    $VMInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.VirtualMachine']$")
		    $VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.VirtualMachine']/VirtualMachineId$", [string]$VM.Summary.Vm )
		    $VMInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
		    $MatchingHost = $VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VM.Runtime.Host}
		
		    If ($MatchingHost){
                if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"    Found Matching Host $($MatchingHost.DisplayName) " | Out-File $EnhancedLoggingPath -append   }

			    #Host Obj (already discovered)
			    $VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
			    $VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$MatchingHost.'[Community.VMware.Class.Host].HostId'.Value )
			    $VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
					
			    #VM references Host
			    $rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.VirtualMachineReferencesHost']$")
			    $rel1.Source = $VMInstance
			    $rel1.Target = $VMhostInstance
			    $discoveryData.AddInstance($rel1)
		    }
	    }
    }
    
$date=Get-Date
$Now=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
        
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)


    if($connection.IsConnected -eq $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }

$discoveryData

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Community.VMware.Discovery.VirtualMachineNetworkReference" Target="Community.VMware.Class.vCenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Community.VMware.Relationship.VirtualMachineReferencesNetwork" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider" RunAs="Community.VMware.SecureReference.RunAsProfile">
          <IntervalSeconds>7200</IntervalSeconds>
          <SyncTime>01:50</SyncTime>
          <ScriptName>Community.VMware.Discovery.VirtualMachineNetworkReference.ps1</ScriptName>
          <ScriptBody><![CDATA[param($sourceId,$managedEntityId,$vCenterServerName)

$ScriptName = 'Community.VMware.Discovery.VirtualMachineNetworkReference.ps1'
$api = new-object -comObject 'MOM.ScriptAPI'

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -InvalidCertificateAction Ignore -ParticipateInCeip $false -Scope Session -Confirm:$false

# <summary>
# 
# Input  :
# --------
#  It receives a *.ini file as Input parametrs.
#
# Output :
# --------
#    Section      Content                                                          
#    -------      -------                                                          
#    [owner]      {name,organization}
#    [database]   {server,port,file}                          
#    
#
# </summary>
 
 
 
function parseIniFile{
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [String] $Inputfile
    )
 
    if ($Inputfile -eq ""){
        Write-Error "Ini File Parser: No file specified or selected to parse."
        Break
    }
    else{
 
        $ContentFile = Get-Content $Inputfile
        # commented Section
        $COMMENT_CHARACTERS = ";"
        # match section header
        $HEADER_REGEX = "\[+[A-Z0-9._ %<>/#+-]+\]" 
 
        $OccurenceOfComment = 0
        $ContentComment   = $ContentFile | Where { ($_ -match "^\s*$COMMENT_CHARACTERS") -or ($_ -match "^$COMMENT_CHARACTERS")  }  | % { 
            [PSCustomObject]@{ Comment= $_ ; 
                    Index = [Array]::IndexOf($ContentFile,$_) 
            }
            $OccurenceOfComment++
        }
 
        $COMMENT_INI = @()
        foreach ($COMMENT_ELEMENT in $ContentComment){
            $COMMENT_OBJ = New-Object PSObject
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Index -value $COMMENT_ELEMENT.Index
            $COMMENT_OBJ | Add-Member  -type NoteProperty -name Comment -value $COMMENT_ELEMENT.Comment
            $COMMENT_INI += $COMMENT_OBJ
        }
 
        $CONTENT_USEFUL = $ContentFile | Where { ($_ -notmatch "^\s*$COMMENT_CHARACTERS") -or ($_ -notmatch "^$COMMENT_CHARACTERS") } 
        $ALL_SECTION_HASHTABLE      = $CONTENT_USEFUL | Where { $_ -match $HEADER_REGEX  } | % { [PSCustomObject]@{ Section= $_ ; Index = [Array]::IndexOf($CONTENT_USEFUL,$_) }}
        #$ContentUncomment | Select-String -AllMatches $HEADER_REGEX | Select-Object -ExpandProperty Matches
 
        $SECTION_INI = @()
        foreach ($SECTION_ELEMENT in $ALL_SECTION_HASHTABLE){
            $SECTION_OBJ = New-Object PSObject
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Index -value $SECTION_ELEMENT.Index
            $SECTION_OBJ | Add-Member  -type NoteProperty -name Section -value $SECTION_ELEMENT.Section
            $SECTION_INI += $SECTION_OBJ
        }
 
        $INI_FILE_CONTENT = @()
        $NBR_OF_SECTION = $SECTION_INI.count
        $NBR_MAX_LINE   = $CONTENT_USEFUL.count
 
        #*********************************************
        # select each lines and value of each section 
        #*********************************************
        for ($i=1; $i -le $NBR_OF_SECTION ; $i++){
            if($i -ne $NBR_OF_SECTION){
                if(($SECTION_INI[$i-1].Index+1) -eq ($SECTION_INI[$i].Index )){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($SECTION_INI[$i].Index-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            else{
                if(($SECTION_INI[$i-1].Index+1) -eq $NBR_MAX_LINE){        
                    $CONVERTED_OBJ = @() #There is nothing between the two section
                } 
                else{
                    $SECTION_STRING = $CONTENT_USEFUL | Select-Object -Index  (($SECTION_INI[$i-1].Index+1)..($NBR_MAX_LINE-1)) | Out-String
                    $CONVERTED_OBJ = convertfrom-stringdata -stringdata $SECTION_STRING
                }
            }
            $CURRENT_SECTION = New-Object PSObject
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Section -Value $SECTION_INI[$i-1].Section
            $CURRENT_SECTION | Add-Member -Type NoteProperty -Name Content -Value $CONVERTED_OBJ
            $INI_FILE_CONTENT += $CURRENT_SECTION
        }
        return $INI_FILE_CONTENT
    }
}
$vCenterINI="C:\vCenter\vCenter.ini"
if (Test-Path $vCenterINI){$a=parseIniFile -Inputfile $vCenterINI}Else{$a="WinvCenter"}

$EnhancedLogging=$a.content.EnhancedLogging
$EnhancedLoggingPath=$a.content.EnhancedLoggingPath
$EnhancedLoggingPath="$EnhancedLoggingPath\$ScriptName.log"

# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Start-Transcript -Path $EnhancedLoggingPath -Append -Verbose -NoClobber -Force}

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenterServerName passed to script: $vCenterServerName " | Out-File $EnhancedLoggingPath -append   }

#
#if( ($a -ne "WinvCenter" -and $a.content.vCenterServerNames -ne ""  -and $a.content.vCenterServerNames -ne $null )){ 
#    $vCenterServerName=($a.content.vCenterServerNames).split(",")
#}else{$vCenter=$vCenterServerName}
#
$vCenter=$vCenterServerName

if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Date: $( Get-Date)" | Out-File $EnhancedLoggingPath -append }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" Source Id: $sourceId,  Managed Entity Id: $managedEntityId,  vCenterServerNames: $vCenterServerName" | Out-File $EnhancedLoggingPath -append  }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ==============================================================" | Out-File $EnhancedLoggingPath -append   }

 
Function ExitPrematurely ($Message) {
	$discoveryData.IsSnapshot = $false
	$api.LogScriptEvent($ScriptName,1985,2,$Message)
	$discoveryData
    # if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Forcing disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append   }

        $connection=Get-VIServer -Server $vCenter -NotDefault  
	    Disconnect-VIServer -Server $connection -Confirm:$false -force:$true
        $connection=Get-VIServer -Server $vCenter -NotDefault
        if($connection.IsConnected -eq $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		    DefaultErrorLogging -vCenter $vCenter
		    Start-Sleep -Seconds 15
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
	exit
}

Function LogScriptEvent {
	Param (
		
		#0 = Informational
		#1 = Error
		#2 = Warning
		[parameter(Mandatory=$true)]
		[ValidateRange(0,2)]
		[int]$EventLevel
		,
		
		[parameter(Mandatory=$true)]
		[string]$Message
	)

	$api.LogScriptEvent($ScriptName,1985,$EventLevel,$Message)
}

Function DefaultErrorLogging {
Param ([string]$vCenter)
	LogScriptEvent -EventLevel 1 -Message ("$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter")

    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"$_`rType:$($_.Exception.GetType().FullName)`r$($_.InvocationInfo.PositionMessage)`rReceivedParam:`rsourceId:$sourceId`rmanagedEntityId:$managedEntityId`rvCenterServerName:$vCenter" | Out-File $EnhancedLoggingPath -append   }
}


$discoveryData = $api.CreateDiscoveryData(0, $sourceId, $managedEntityId)

Try {Import-Module OperationsManager}
Catch {DefaultErrorLogging}

Try {New-SCOMManagementGroupConnection 'localhost'}
Catch {DefaultErrorLogging}

Try {$MGconn = Get-SCOMManagementGroupConnection | Where {$_.IsActive -eq $true}}
Catch {DefaultErrorLogging}

If(!$MGconn){
	ExitPrematurely ("Unable to connect to the local management group")
}

#Get Already Discovered Virtual Machines from SCOM
Try {$VMobjs = Get-SCOMClass -Name 'Community.VMware.Class.VirtualMachine' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging}

#Exit if no VMs are discovered, because there is no relationship to build
If (!$VMobjs){
	ExitPrematurely ("No VMs found discovered in SCOM for vCenter " + $vCenter)
}

#Get Already Discovered VMhosts
Try {$VMhostObjs	= Get-SCOMClass -Name 'Community.VMware.Class.Host' | Get-SCOMClassInstance | Where {$_.'[Community.VMware.Class.vCenter].vCenterServerName'.Value -eq $vCenter}}
Catch {DefaultErrorLogging}

Try {
	Import-Module VMware.VimAutomation.Core
} Catch {
	Start-Sleep -Seconds 10
	Try {
		Import-Module VMware.VimAutomation.Core
	} Catch {
		DefaultErrorLogging
        
		ExitPrematurely("Unable to Import VMware Module")
	}
}

$date=Get-Date
if($vCenter -ne $null -and $vcenter -ne ""){
    
    do {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connecting to vCenter Server Name: $vCenter, Opening new session" | Out-File $EnhancedLoggingPath -append   }
        $connection = Connect-VIServer -Server $vCenter -Force:$true -NotDefault
        if($connection.IsConnected -ne $true){
            if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
	        DefaultErrorLogging -vCenter $vCenter
            #Disconnect-VIServer -Server $vCenter -force:$true -confirm:$false
	        Start-Sleep -Seconds 10
            
   	    }
        $Now=Get-Date
    }While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -ne $true)

    if($connection.IsConnected -ne $true){
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to connect to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
        DefaultErrorLogging -vCenter $vCenter
        ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
    }Else{
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Connected to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    }
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"No vCenter Server Name passes, Exiting" | Out-File $EnhancedLoggingPath -append} 

    ExitPrematurely ("No vCenter Server Name passes, Exiting")
}


Try {$VMwareVirtualMachines = (Get-View -Server $connection -ViewType VirtualMachine -Property Name,Runtime,Summary -Filter @{"Config.Template"="false"}) | Select Name,Runtime,Summary}
Catch {DefaultErrorLogging}

If (!$VMwareVirtualMachines){
	Try {Disconnect-VIServer -Server $connection -Confirm:$false}
	Catch {DefaultErrorLogging}
	ExitPrematurely ("No VMs found in vCenter " + $vCenter)
}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"vCenter Server: $vCenter " | Out-File $EnhancedLoggingPath -append   }

ForEach ($VMhost in $VMwareHosts){

	If ($VMhostObjs | Where {$_.'[Community.VMware.Class.Host].HostId'.Value -eq [string]$VMhost.MoRef}){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"    Found VMHost $VMhost" | Out-File $EnhancedLoggingPath -append   }

		#VM Host Obj (already discovered)
		$VMhostInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Host']$")
		$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Host']/HostId$", [string]$VMhost.MoRef )
		$VMhostInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
		
		ForEach ($VMnetwork in $VMhost.Network){
			    

			$MatchingNetwork = $VMnetworkObjs | Where {$_.'[Community.VMware.Class.Network].NetworkId'.Value -eq [string]$VMnetwork}
			If ($MatchingNetwork){
                if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"      Found Matching Network $VMNetwork" | Out-File $EnhancedLoggingPath -append   }
				#Network Obj (already discovered)
				$VMnetworkInstance = $discoveryData.CreateClassInstance("$MPElement[Name='Community.VMware.Class.Network']$")
				$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.Network']/NetworkId$", [string]$MatchingNetwork.'[Community.VMware.Class.Network].NetworkId'.Value )
				$VMnetworkInstance.AddProperty("$MPElement[Name='Community.VMware.Class.vCenter']/vCenterServerName$", $vCenter )
				
				#VM references Network
				$rel1 = $discoveryData.CreateRelationshipInstance("$MPElement[Name='Community.VMware.Relationship.HostReferencesNetwork']$")
				$rel1.Source = $VMhostInstance
				$rel1.Target = $VMnetworkInstance
				$discoveryData.AddInstance($rel1)
			}
		}
	}
}
#    Try {Disconnect-VIServer -Server $connection -Confirm:$false}
#    Catch {DefaultErrorLogging}
    
$date=Get-Date
$Now=Get-Date
do {
    Try {
		Disconnect-VIServer -Server $connection -Confirm:$false  

	} Catch {
        if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter, will retry in 10 Seconds" | Out-File $EnhancedLoggingPath -append   }
		#DefaultErrorLogging -vCenter $vCenter
		Start-Sleep -Seconds 10
   	}
        
}While($Now -lt $date.AddMinutes(1) -and $connection.IsConnected -eq $true)



if($connection.IsConnected -eq $true){
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Unable to disconnect from vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
    DefaultErrorLogging -vCenter $vCenter
    ExitPrematurely ("Unable to disconnect from vCenter server " + $vCenter)
}Else{
    if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"Disconnected from to vCenter Server Name: $vCenter" | Out-File $EnhancedLoggingPath -append} 
}

$discoveryData
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" ============  vCenter $vCenter finnished  ====================" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" " | Out-File $EnhancedLoggingPath -append   }
# if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {Stop-Transcript -Verbose}
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {"PID: $PID" | Out-File $EnhancedLoggingPath -append   }
if($EnhancedLogging -eq "true" -or $EnhancedLogging -eq "yes") {" **********************$(Get-date)****************************************" | Out-File $EnhancedLoggingPath -append   }

Exit]]></ScriptBody>
          <Parameters>
            <Parameter>
              <Name>sourceID</Name>
              <Value>$MPElement$</Value>
            </Parameter>
            <Parameter>
              <Name>managedEntityID</Name>
              <Value>$Target/Id$</Value>
            </Parameter>
            <Parameter>
              <Name>vCenterServerName</Name>
              <Value>$Target/Property[Type="Community.VMware.Class.vCenter"]/vCenterServerName$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
    </Discoveries>
    <Rules>
      <Rule ID="Community.VMware.CollectionRule.ClusterDatastoreSpaceUsedPercent" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>Datastore Space Used Percent</CounterName>
            <PerfValueName>USED_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.ClusterCpuUsageAvg" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>cpu.usage.average</CounterName>
            <PerfValueName>cpu.usage.average</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.ClusterMemoryUsageAvg" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>mem.usage.average</CounterName>
            <PerfValueName>mem.usage.average</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.ClusterDatastoreSpaceCapacityGB" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>Datastore Space Capacity GB</CounterName>
            <PerfValueName>CAPACITY_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.ClusterDatastoreSpaceFreeGB" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>Datastore Space Free GB</CounterName>
            <PerfValueName>FREE_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.ClusterDatastoreSpaceUsedGB" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>Datastore Space Used GB</CounterName>
            <PerfValueName>USED_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.ClusterDatastoreSpaceFreePercent" Target="Community.VMware.Class.Cluster" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.ClusterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>600</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
            <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
            <CounterName>Datastore Space Free Percent</CounterName>
            <PerfValueName>FREE_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatacenterDatastoreSpaceCapacityTB" Target="Community.VMware.Class.Datacenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatacenterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatacenterId>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterId$</DatacenterId>
            <DatacenterName>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterName$</DatacenterName>
            <CounterName>Datastore Space Capacity TB</CounterName>
            <PerfValueName>CAPACITY_TB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatacenterDatastoreSpaceUsedTB" Target="Community.VMware.Class.Datacenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatacenterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatacenterId>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterId$</DatacenterId>
            <DatacenterName>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterName$</DatacenterName>
            <CounterName>Datastore Space Used TB</CounterName>
            <PerfValueName>USED_TB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatacenterDatastoreSpaceFreeTB" Target="Community.VMware.Class.Datacenter" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatacenterDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatacenterId>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterId$</DatacenterId>
            <DatacenterName>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterName$</DatacenterName>
            <CounterName>Datastore Space Free TB</CounterName>
            <PerfValueName>FREE_TB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatastoreSpaceCapacityGB" Target="Community.VMware.Class.Datastore" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
            <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
            <CounterName>Space Capacity GB</CounterName>
            <PerfValueName>CAPACITY_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatastoreSpaceFreePercent" Target="Community.VMware.Class.Datastore" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
            <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
            <CounterName>Space Free Percent</CounterName>
            <PerfValueName>FREE_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatastoreSpaceFreeGB" Target="Community.VMware.Class.Datastore" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
            <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
            <CounterName>Space Free GB</CounterName>
            <PerfValueName>FREE_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatastoreSpaceUsedPercent" Target="Community.VMware.Class.Datastore" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
            <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
            <CounterName>Space Used Percent</CounterName>
            <PerfValueName>USED_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.DatastoreSpaceUsedGB" Target="Community.VMware.Class.Datastore" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.DatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
            <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
            <CounterName>Space Used GB</CounterName>
            <PerfValueName>USED_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostMemoryFreeMB" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>Memory Free MB</CounterName>
            <PerfValueName>MEM_FreeMB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostCPUfreeMHz" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>CPU Free MHz</CounterName>
            <PerfValueName>CPU_FreeMHz</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostCPUusagePercent" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>CPU Usage Percent</CounterName>
            <PerfValueName>CPU_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostCPUusageMHz" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>CPU Usage MHz</CounterName>
            <PerfValueName>CPU_UsageMHz</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostMemoryUsagePercent" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>Memory Usage Percent</CounterName>
            <PerfValueName>MEM_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostMemoryUsageMB" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>Memory Usage MB</CounterName>
            <PerfValueName>MEM_UsageMB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostCPUcapacityMHz" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>CPU Capacity MHz</CounterName>
            <PerfValueName>CPU_MaxMHz</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostMemoryCapacityMB" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostPerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <CounterName>Memory Capacity MB</CounterName>
            <PerfValueName>MEM_MaxMB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostDatastoreSpaceCapacityGB" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <IsStandalone>$Target/Property[Type='Community.VMware.Class.Host']/IsStandalone$</IsStandalone>
            <CounterName>Datastore Space Capacity GB</CounterName>
            <PerfValueName>CAPACITY_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostDatastoreSpaceUsedPercent" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <IsStandalone>$Target/Property[Type='Community.VMware.Class.Host']/IsStandalone$</IsStandalone>
            <CounterName>Datastore Space Used Percent</CounterName>
            <PerfValueName>USED_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostDatastoreSpaceUsedGB" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <IsStandalone>$Target/Property[Type='Community.VMware.Class.Host']/IsStandalone$</IsStandalone>
            <CounterName>Datastore Space Used GB</CounterName>
            <PerfValueName>USED_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostDatastoreSpaceFreeGB" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <IsStandalone>$Target/Property[Type='Community.VMware.Class.Host']/IsStandalone$</IsStandalone>
            <CounterName>Datastore Space Free GB</CounterName>
            <PerfValueName>FREE_GB</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Community.VMware.CollectionRule.HostDatastoreSpaceFreePercent" Target="Community.VMware.Class.Host" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Community.VMware.DataSource.HostDatastorePerfOptimized" RunAs="Community.VMware.SecureReference.RunAsProfile">
            <IntervalSeconds>600</IntervalSeconds>
            <SyncTime>00:00</SyncTime>
            <TimeoutSeconds>300</TimeoutSeconds>
            <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
            <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
            <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
            <IsStandalone>$Target/Property[Type='Community.VMware.Class.Host']/IsStandalone$</IsStandalone>
            <CounterName>Datastore Space Free Percent</CounterName>
            <PerfValueName>FREE_Percent</PerfValueName>
            <Tolerance>0</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>1</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="CollectToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="CollectToDW" TypeID="MSDL!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
    </Rules>
    <Monitors>
      <UnitMonitor ID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.ClusterDatastorePerfBelowThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Cluster"]/ClusterName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>600</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
          <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
          <CounterName>Datastore Space Free Percent</CounterName>
          <PerfValueName>FREE_Percent</PerfValueName>
          <WarningThreshold>15</WarningThreshold>
          <CriticalThreshold>2</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.ClusterCurentFailoverLevelBelowThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Cluster"]/ClusterName$</AlertParameter1>
            <AlertParameter2>$Data/Context/Property[@Name='CurrentFailoverLevel']$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>300</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
          <WarningThreshold>1</WarningThreshold>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.ClusterPerfAboveThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Cluster"]/ClusterName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>600</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>600</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
          <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
          <CounterName>mem.usage.average</CounterName>
          <PerfValueName>mem.usage.average</PerfValueName>
          <WarningThreshold>80</WarningThreshold>
          <CriticalThreshold>95</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.ClusterPerfAboveThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.ClusterCpuUsageAvg.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Cluster"]/ClusterName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>600</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>600</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <ClusterId>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterId$</ClusterId>
          <ClusterName>$Target/Property[Type='Community.VMware.Class.Cluster']/ClusterName$</ClusterName>
          <CounterName>cpu.usage.average</CounterName>
          <PerfValueName>cpu.usage.average</PerfValueName>
          <WarningThreshold>75</WarningThreshold>
          <CriticalThreshold>95</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Datacenter" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.DatacenterDatastorePerfBelowThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Datacenter"]/DatacenterName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>600</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <DatacenterId>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterId$</DatacenterId>
          <DatacenterName>$Target/Property[Type='Community.VMware.Class.Datacenter']/DatacenterName$</DatacenterName>
          <CounterName>Datastore Space Free Percent</CounterName>
          <PerfValueName>FREE_Percent</PerfValueName>
          <WarningThreshold>10</WarningThreshold>
          <CriticalThreshold>2</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.DatastoreState" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Datastore" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.DatastoreState" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.DatastoreState.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='State']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Available" MonitorTypeStateID="Available" HealthState="Success" />
          <OperationalState ID="Unavailable" MonitorTypeStateID="Unavailable" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>120</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>120</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Datastore" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.DatastorePerfBelowThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Datastore"]/DatastoreName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>300</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
          <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
          <CounterName>Space Free Percent</CounterName>
          <PerfValueName>FREE_Percent</PerfValueName>
          <WarningThreshold>10</WarningThreshold>
          <CriticalThreshold>2</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Datastore" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.DatastorePerfBelowThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Datastore"]/DatastoreName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>300</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <DatastoreId>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreId$</DatastoreId>
          <DatastoreName>$Target/Property[Type='Community.VMware.Class.Datastore']/DatastoreName$</DatastoreName>
          <CounterName>Space Free GB</CounterName>
          <PerfValueName>FREE_GB</PerfValueName>
          <WarningThreshold>10</WarningThreshold>
          <CriticalThreshold>1</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.HostMemoryUsagePercent" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Host" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.HostPerfAboveThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.HostMemoryUsagePercent.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Host"]/HostName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>300</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
          <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
          <CounterName>Memory Usage Percent</CounterName>
          <PerfValueName>MEM_Percent</PerfValueName>
          <WarningThreshold>90</WarningThreshold>
          <CriticalThreshold>98</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Host" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.HostDatastorePerfBelowThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Host"]/HostName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>600</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
          <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
          <IsStandalone>$Target/Property[Type='Community.VMware.Class.Host']/IsStandalone$</IsStandalone>
          <CounterName>Datastore Space Free Percent</CounterName>
          <PerfValueName>FREE_Percent</PerfValueName>
          <WarningThreshold>15</WarningThreshold>
          <CriticalThreshold>2</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.HostCPUusagePercent" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Host" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.HostPerfAboveThreshold" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.HostCPUusagePercent.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Host"]/HostName$</AlertParameter1>
            <AlertParameter2>$Data/Context/SampleValue$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>300</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>300</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
          <HostName>$Target/Property[Type='Community.VMware.Class.Host']/HostName$</HostName>
          <CounterName>CPU Usage Percent</CounterName>
          <PerfValueName>CPU_Percent</PerfValueName>
          <WarningThreshold>75</WarningThreshold>
          <CriticalThreshold>95</CriticalThreshold>
          <NumSamples>0</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.HostPowerState" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Host" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.HostPowerState" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.HostPowerState.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='PowerState']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="PoweredOn" MonitorTypeStateID="PoweredOn" HealthState="Success" />
          <OperationalState ID="NotPoweredOn" MonitorTypeStateID="NotPoweredOn" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>120</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>120</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <HostId>$Target/Property[Type='Community.VMware.Class.Host']/HostId$</HostId>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.NetworkOverallStatus" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Network" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.NetworkOverallStatus" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.NetworkOverallStatus.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Community.VMware.Class.Network"]/NetworkName$</AlertParameter1>
            <AlertParameter2>$Data/Context/Property[@Name='OverallStatus']$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Healthy" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="Warning" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="Critical" MonitorTypeStateID="Critical" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>120</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>120</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <NetworkId>$Target/Property[Type='Community.VMware.Class.Network']/NetworkId$</NetworkId>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.vAppStartedState" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.vApp" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.vAppStartedState" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.vAppStartedState.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='State']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Started" MonitorTypeStateID="Started" HealthState="Success" />
          <OperationalState ID="NotStarted" MonitorTypeStateID="NotStarted" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>120</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>120</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <vAppId>$Target/Property[Type='Community.VMware.Class.vApp']/vAppId$</vAppId>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Community.VMware.UnitMonitor.VirtualMachinePowerState" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.VirtualMachine" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Community.VMware.MonitorType.VirtualMachinePowerState" ConfirmDelivery="false" RunAs="Community.VMware.SecureReference.RunAsProfile">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Community.VMware.UnitMonitor.VirtualMachinePowerState.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='PowerState']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="PoweredOn" MonitorTypeStateID="PoweredOn" HealthState="Success" />
          <OperationalState ID="NotPoweredOn" MonitorTypeStateID="NotPoweredOn" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>120</IntervalSeconds>
          <SyncTime>00:00</SyncTime>
          <TimeoutSeconds>120</TimeoutSeconds>
          <vCenterServerName>$Target/Host/Property[Type='Community.VMware.Class.vCenter']/vCenterServerName$</vCenterServerName>
          <VirtualMachineId>$Target/Property[Type='Community.VMware.Class.VirtualMachine']/VirtualMachineId$</VirtualMachineId>
        </Configuration>
      </UnitMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.ClusterDependsOnHostAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.ClusterContainsHost" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>BestOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.ClusterDependsOnHostPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.ClusterContainsHost" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>BestOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterClusterAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterContainsCluster" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresDatastoreAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostDatastoresContainsDatastore" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostHostPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostContainsHost" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresDatastorePerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostDatastoresContainsDatastore" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresDatastorePerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterDatastoresContainsDatastore" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsDatastores" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostHostAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostContainsHost" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllStandaloneHostsHostPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.AllStandaloneHostsHostsStandaloneHost" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresDatastoreAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterDatastoresContainsDatastore" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.vCenterHostsAndClustersPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.vCenter" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.vCenterHostsHostsAndClusters" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.vCenterHostsAndClustersAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.vCenter" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.vCenterHostsHostsAndClusters" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.HostsAndClustersDatacenterAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClustersHostsDatacenter" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.HostsAndClustersDatacenterPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClustersHostsDatacenter" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllClustersPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllClusters" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllClustersClusterPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.AllClustersHostsCluster" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllStandaloneHostsPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllStandaloneHosts" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllClustersAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllClusters" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllClustersClusterAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.AllClustersHostsCluster" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllStandaloneHostsAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllStandaloneHosts" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllStandaloneHostsHostAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.AllStandaloneHostsHostsStandaloneHost" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterClusterPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterContainsCluster" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsDatastores" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsDatastores" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsDatastores" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsNetworks" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsNetworks" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksNetworkAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostNetworksContainsNetwork" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksNetworkPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostNetworksContainsNetwork" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsNetworks" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsNetworks" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksNetworkAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterNetworksContainsNetwork" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksNetworkPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterNetworksContainsNetwork" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsvApps" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsvAppPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostvAppsContainsvApp" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsvAppAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostvAppsContainsvApp" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsvApps" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsvApps" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppsvAppPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClustervAppsContainsvApp" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppsvAppsAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClustervAppsContainsvApp" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppsAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsvApps" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesVirtualMachinePerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesContainsVirtualMachine" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesVirtualMachineAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesContainsVirtualMachine" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinePerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsVirtualMachines" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsVirtualMachines" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesVirtualMachineAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterVirtualMachinesContainsVirtualMachine" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesVirtualMachinePerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterVirtualMachinesContainsVirtualMachine" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesAvailability" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsVirtualMachines" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
      <DependencyMonitor ID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesPerformance" Accessibility="Internal" Enabled="true" Target="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsVirtualMachines" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </DependencyMonitor>
    </Monitors>
    <Overrides>
      <MonitorPropertyOverride ID="Community.VMware.Override.DisableClusterCurrentFailoverLevelMonitor" Property="Enabled" Monitor="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel" Context="Community.VMware.Class.Group.ClustersWithoutHA" Enforced="false">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride Property="Algorithm" Monitor="Community.VMware.DependencyMonitor.ClusterDependsOnHostAvailability" Context="Community.VMware.Class.Group.ClustersWithoutHA" Enforced="false" ID="Community.VMware.Override.ClusterDependsOnHostAvailabilityAlgorithm">
        <Value>WorstOf</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride Property="Algorithm" Monitor="Community.VMware.DependencyMonitor.ClusterDependsOnHostPerformance" Context="Community.VMware.Class.Group.ClustersWithoutHA" Enforced="false" ID="Community.VMware.Override.ClusterDependsOnHostPerformanceAlgorithm">
        <Value>WorstOf</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Community.VMware.Override.vCenterServerServiceStatusAlertPriority" Monitor="MSNL!Microsoft.SystemCenter.NTService.ServiceStateMonitor" Context="Community.VMware.Class.vCenterServerService" Property="AlertPriority" Enforced="false">
        <Value>High</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride Property="Enabled" Monitor="Community.VMware.UnitMonitor.VirtualMachinePowerState" Context="Community.VMware.Class.Group.UnmonitoredVirtualMachines" Enforced="false" ID="Community.VMware.Override.VirtualMachinePowerStateDisabler">
        <Value>false</Value>
      </MonitorPropertyOverride>
    </Overrides>
  </Monitoring>
  <Presentation>
    <Views>
      <View ID="Community.VMware.View.UnixReference" Accessibility="Internal" Target="Unix!Microsoft.Unix.Computer" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="false">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.StatevCenter" Accessibility="Internal" Target="Community.VMware.Class.vCenter" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
        <Presentation>
          <ColumnInfo Index="0" SortIndex="0" Width="100" Grouped="false" Sorted="true" IsSortable="true" Visible="true" SortOrder="Descending">
            <Name>State</Name>
            <Id>Community.VMware.Class.vCenter</Id>
          </ColumnInfo>
          <ColumnInfo Index="1" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>In Maintenance Mode</Name>
            <Id>InMaintenanceMode</Id>
          </ColumnInfo>
          <ColumnInfo Index="2" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Name</Name>
            <Id>Name</Id>
          </ColumnInfo>
          <ColumnInfo Index="3" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Path</Name>
            <Id>Path</Id>
          </ColumnInfo>
          <ColumnInfo Index="4" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Display Name</Name>
            <Id>System.Entity/DisplayName</Id>
          </ColumnInfo>
          <ColumnInfo Index="5" SortIndex="-1" Width="150" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>vCenter Server Name</Name>
            <Id>Community.VMware.Class.vCenter/vCenterServerName</Id>
          </ColumnInfo>
          <ColumnInfo Index="10" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - vApp</Name>
            <Id>Community.VMware.Class.vApp</Id>
          </ColumnInfo>
          <ColumnInfo Index="8" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - Host</Name>
            <Id>Community.VMware.Class.Host</Id>
          </ColumnInfo>
          <ColumnInfo Index="9" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - Virtual Machine</Name>
            <Id>Community.VMware.Class.VirtualMachine</Id>
          </ColumnInfo>
          <ColumnInfo Index="12" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - Network</Name>
            <Id>Community.VMware.Class.Network</Id>
          </ColumnInfo>
          <ColumnInfo Index="11" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - Datastore</Name>
            <Id>Community.VMware.Class.Datastore</Id>
          </ColumnInfo>
          <ColumnInfo Index="6" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - Datacenter</Name>
            <Id>Community.VMware.Class.Datacenter</Id>
          </ColumnInfo>
          <ColumnInfo Index="7" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Community - VMware - Cluster</Name>
            <Id>Community.VMware.Class.Cluster</Id>
          </ColumnInfo>
        </Presentation>
      </View>
      <View ID="Community.VMware.View.StateVirtualMachine" Accessibility="Internal" Target="Community.VMware.Class.VirtualMachine" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.StateHost" Accessibility="Internal" Target="Community.VMware.Class.Host" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.DaigramvCenterRollup" Accessibility="Internal" Target="Community.VMware.Class.Group.Rollup.vCenter" TypeID="SC!Microsoft.SystemCenter.DiagramViewType" Visible="true">
        <Category>Operations</Category>
        <Presentation>
          <DiagramViewCriteria>
            <DiagramViewDisplay ShowVirtualGroup="false">
              <ContainmentStyle>Box</ContainmentStyle>
              <NodesPerRow>5</NodesPerRow>
              <LevelsToShow>2</LevelsToShow>
              <ContainmentLine>
                <Color />
                <SourceArrow IsFilled="false">
                  <ArrowStyle>NoAnchor</ArrowStyle>
                </SourceArrow>
                <TargetArrow IsFilled="false">
                  <ArrowStyle>ArrowAnchor</ArrowStyle>
                </TargetArrow>
              </ContainmentLine>
              <NonContainmentLine>
                <Color Red="6" Green="134" Blue="253" />
                <SourceArrow IsFilled="false">
                  <ArrowStyle>NoAnchor</ArrowStyle>
                </SourceArrow>
                <TargetArrow IsFilled="false">
                  <ArrowStyle>ArrowAnchor</ArrowStyle>
                </TargetArrow>
                <LineStyle>DashDotDot</LineStyle>
              </NonContainmentLine>
            </DiagramViewDisplay>
          </DiagramViewCriteria>
        </Presentation>
      </View>
      <View ID="Community.VMware.View.StateCluster" Accessibility="Internal" Target="Community.VMware.Class.Cluster" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.StateDatastore" Accessibility="Internal" Target="Community.VMware.Class.Datastore" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.AlertAllObjects" Accessibility="Internal" Target="System!System.Entity" TypeID="SC!Microsoft.SystemCenter.AlertViewType" Visible="true">
        <Category>Operations</Category>
        <Criteria>
          <ResolutionState>
            <StateRange Operator="NotEquals">255</StateRange>
          </ResolutionState>
        </Criteria>
        <Target>$MPElement[Name="Community.VMware.Class.Group.AllObjects"]$</Target>
      </View>
      <View ID="Community.VMware.View.StateDatacenter" Accessibility="Internal" Target="Community.VMware.Class.Datacenter" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.StateNetwork" Accessibility="Internal" Target="Community.VMware.Class.Network" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
      <View ID="Community.VMware.View.StatevApp" Accessibility="Internal" Target="Community.VMware.Class.vApp" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
      </View>
    </Views>
    <Folders>
      <Folder ID="Community.VMware.Folder.Root" Accessibility="Public" ParentFolder="SC!Microsoft.SystemCenter.Monitoring.ViewFolder.Root" />
      <Folder ID="Community.VMware.Folder.InventoryObjects" Accessibility="Public" ParentFolder="Community.VMware.Folder.Root" />
    </Folders>
    <FolderItems>
      <FolderItem ElementID="Community.VMware.View.UnixReference" Folder="Unix!Microsoft.Unix.Folder.Root" ID="Community.VMware.View.UnixReference.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StatevCenter" Folder="Community.VMware.Folder.Root" ID="Community.VMware.View.StatevCenter.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StateVirtualMachine" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StateVirtualMachine.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StateHost" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StateHost.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.DaigramvCenterRollup" Folder="Community.VMware.Folder.Root" ID="Community.VMware.View.DaigramvCenterRollup.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StateCluster" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StateCluster.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StateDatastore" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StateDatastore.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.AlertAllObjects" Folder="Community.VMware.Folder.Root" ID="Community.VMware.View.AlertAllObjects.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StateDatacenter" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StateDatacenter.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StateNetwork" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StateNetwork.FolderItem" />
      <FolderItem ElementID="Community.VMware.View.StatevApp" Folder="Community.VMware.Folder.InventoryObjects" ID="Community.VMware.View.StatevApp.FolderItem" />
    </FolderItems>
    <ImageReferences>
      <ImageReference ElementID="Community.VMware.Class.Cluster" ImageID="Community.VMware.Image.Cluster.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Cluster" ImageID="Community.VMware.Image.Cluster.Small" />
      <ImageReference ElementID="Community.VMware.Class.Datacenter" ImageID="Community.VMware.Image.Datacenter.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Datacenter" ImageID="Community.VMware.Image.Datacenter.Small" />
      <ImageReference ElementID="Community.VMware.Class.Datastore" ImageID="Community.VMware.Image.Datastore.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Datastore" ImageID="Community.VMware.Image.Datastore.Small" />
      <ImageReference ElementID="Community.VMware.Class.Host" ImageID="Community.VMware.Image.Host.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Host" ImageID="Community.VMware.Image.Host.Small" />
      <ImageReference ElementID="Community.VMware.Class.Network" ImageID="Community.VMware.Image.Network.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Network" ImageID="Community.VMware.Image.Network.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.vCenter" ImageID="Community.VMware.Image.vCenter.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.vCenter" ImageID="Community.VMware.Image.vCenter.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" ImageID="Community.VMware.Image.Datacenter.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" ImageID="Community.VMware.Image.Datacenter.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" ImageID="Community.VMware.Image.Cluster.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" ImageID="Community.VMware.Image.Cluster.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ImageID="Community.VMware.Image.Cluster.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" ImageID="Community.VMware.Image.Cluster.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" ImageID="Community.VMware.Image.Host.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" ImageID="Community.VMware.Image.Host.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ImageID="Community.VMware.Image.Host.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" ImageID="Community.VMware.Image.Host.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" ImageID="Community.VMware.Image.VirtualMachine.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" ImageID="Community.VMware.Image.VirtualMachine.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" ImageID="Community.VMware.Image.VirtualMachine.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" ImageID="Community.VMware.Image.VirtualMachine.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" ImageID="Community.VMware.Image.Datastore.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" ImageID="Community.VMware.Image.Datastore.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" ImageID="Community.VMware.Image.Datastore.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" ImageID="Community.VMware.Image.Datastore.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" ImageID="Community.VMware.Image.Network.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" ImageID="Community.VMware.Image.Network.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" ImageID="Community.VMware.Image.Network.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" ImageID="Community.VMware.Image.Network.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" ImageID="Community.VMware.Image.vApp.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" ImageID="Community.VMware.Image.vApp.Small" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" ImageID="Community.VMware.Image.vApp.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" ImageID="Community.VMware.Image.vApp.Small" />
      <ImageReference ElementID="Community.VMware.Class.vApp" ImageID="Community.VMware.Image.vApp.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.vApp" ImageID="Community.VMware.Image.vApp.Small" />
      <ImageReference ElementID="Community.VMware.Class.vCenter" ImageID="Community.VMware.Image.vCenter.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.vCenter" ImageID="Community.VMware.Image.vCenter.Small" />
      <ImageReference ElementID="Community.VMware.Class.VirtualMachine" ImageID="Community.VMware.Image.VirtualMachine.Diagram" />
      <ImageReference ElementID="Community.VMware.Class.VirtualMachine" ImageID="Community.VMware.Image.VirtualMachine.Small" />
    </ImageReferences>
    <StringResources>
      <StringResource ID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.DatastoreState.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.HostMemoryUsagePercent.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.HostCPUusagePercent.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.HostPowerState.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.NetworkOverallStatus.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.vAppStartedState.AlertMessage" />
      <StringResource ID="Community.VMware.UnitMonitor.VirtualMachinePowerState.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="true">
      <DisplayStrings>
        <DisplayString ElementID="Community.VMware.Discovery.Cluster">
          <Name>VMware Cluster Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover Clusters</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.ClusterDatacenterReference">
          <Name>VMware Cluster Datacenter Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Cluster Datacenter Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.ClusterHostContainment">
          <Name>VMware Cluster Host Containment Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Cluster Host Containment Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterDatastoreSpaceUsedPercent">
          <Name>VMware Cluster Datastore Space Used Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterCpuUsageAvg">
          <Name>VMware Cluster CPU Usage Average Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent">
          <Name>VMware Cluster Datastore Space Free Percent</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent.AlertMessage">
          <Name>VMware Cluster Datastore Space Free Percent</Name>
          <Description>The datastore free percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterDatastoreSpaceFreePercent" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel">
          <Name>VMware Cluster Current Failover Level</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel.AlertMessage">
          <Name>VMware Cluster Current Failover Level</Name>
          <Description>The current failover level of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCurrentFailoverLevel" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterMemoryUsageAvg">
          <Name>VMware Cluster Memory Usage Average Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterDatastoreSpaceCapacityGB">
          <Name>VMware Cluster Datastore Space Capacity GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterDatastoreSpaceFreeGB">
          <Name>VMware Cluster Datastore Space Free GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterDatastoreSpaceUsedGB">
          <Name>VMware Cluster Datastore Space Used GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.ClusterDatastoreSpaceFreePercent">
          <Name>VMware Cluster Datastore Space Free Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg">
          <Name>VMware Cluster Memory Usage Average</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg.AlertMessage">
          <Name>VMware Cluster Memory Usage Average</Name>
          <Description>The memory usage percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterMemoryUsageAvg" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg">
          <Name>VMware Cluster CPU Usage Average</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg.AlertMessage">
          <Name>VMware Cluster CPU Usage Average</Name>
          <Description>The CPU usage percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.ClusterCpuUsageAvg" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.ClusterDependsOnHostAvailability">
          <Name>Host Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.ClusterDependsOnHostPerformance">
          <Name>Host Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Datacenter">
          <Name>VMware Datacenter Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover Datacenters</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatacenterDatastoreSpaceCapacityTB">
          <Name>VMware Datacenter Datastore Space Capacity TB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatacenterDatastoreSpaceUsedTB">
          <Name>VMware Datacenter Datastore Space Used TB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent">
          <Name>VMware Datacenter Datastore Space Free Percent</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent.AlertMessage">
          <Name>VMware Datacenter Datastore Space Free Percent</Name>
          <Description>The datastore free percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatacenterDatastoreSpaceFreePercent" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatacenterDatastoreSpaceFreeTB">
          <Name>VMware Datacenter Datastore Space Free TB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Datastore">
          <Name>VMware Datastore Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover Datastores</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatastoreSpaceCapacityGB">
          <Name>VMware Datastore Space Capacity GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatastoreSpaceFreePercent">
          <Name>VMware Datastore Space Free Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatastoreSpaceFreeGB">
          <Name>VMware Datastore Space Free GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatastoreSpaceUsedPercent">
          <Name>VMware Datastore Space Used Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.DatastoreSpaceUsedGB">
          <Name>VMware Datastore Space Used GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreState">
          <Name>VMware Datastore State</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreState.AlertMessage">
          <Name>VMware Datastore State</Name>
          <Description>The datastore's current state is {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreState" SubElementID="Available">
          <Name>Available</Name>
          <Description>Available</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreState" SubElementID="Unavailable">
          <Name>Unavailable</Name>
          <Description>Unavailable</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent">
          <Name>VMware Datastore Space Free Percent</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent.AlertMessage">
          <Name>VMware Datastore Space Free Percent</Name>
          <Description>The datastore space free percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreePercent" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB">
          <Name>VMware Datastore Space Free GB</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB.AlertMessage">
          <Name>VMware Datastore Space Free GB</Name>
          <Description>The datastore space free GB of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.DatastoreSpaceFreeGB" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Group.AllObjects">
          <Name>Community - VMware All Objects Group Discovery</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Group.ClustersWithoutHA">
          <Name>Community - VMware Clusters Without HA Group Discovery</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Group.Rollup.vCenter">
          <Name>Community - VMware Rollup - vCenter Group Discovery</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Host">
          <Name>VMware Host Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover Hosts</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.HostDatastoreReference">
          <Name>VMware Host Datastore Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Host Datastore Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.HostNetworkReference">
          <Name>VMware Host Network Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Host Network Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.HostDatacenterReference">
          <Name>VMware Host Datacenter Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Host Datacenter Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostMemoryFreeMB">
          <Name>VMware Host Memory Usage Free Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostCPUfreeMHz">
          <Name>VMware Host CPU Free MHz Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostCPUusagePercent">
          <Name>VMware Host CPU Usage Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostCPUusageMHz">
          <Name>VMware Host CPU Usage MHz Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostMemoryUsagePercent">
          <Name>VMware Host Memory Usage Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostMemoryUsageMB">
          <Name>VMware Host Memory Usage MB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostCPUcapacityMHz">
          <Name>VMware Host CPU Capacity MHz Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostMemoryCapacityMB">
          <Name>VMware Host Memory Usage Capacity Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostMemoryUsagePercent">
          <Name>VMware Host Memory Usage Percent</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostMemoryUsagePercent.AlertMessage">
          <Name>VMware Host Memory Usage Percent</Name>
          <Description>The Memory usage percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostMemoryUsagePercent" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostMemoryUsagePercent" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostMemoryUsagePercent" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent">
          <Name>VMware Host Datastore Space Free Percent</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent.AlertMessage">
          <Name>VMware Host Datastore Space Free Percent</Name>
          <Description>The datastore free percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostDatastoreSpaceFreePercent" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostCPUusagePercent">
          <Name>VMware Host CPU Usage Percent</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostCPUusagePercent.AlertMessage">
          <Name>VMware Host CPU Usage Percent</Name>
          <Description>The CPU usage percent of {0} is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostCPUusagePercent" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostCPUusagePercent" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostCPUusagePercent" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostDatastoreSpaceCapacityGB">
          <Name>VMware Host Datastore Space Capacity GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostDatastoreSpaceUsedPercent">
          <Name>VMware Host Datastore Space Used Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostDatastoreSpaceUsedGB">
          <Name>VMware Host Datastore Space Used GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostDatastoreSpaceFreeGB">
          <Name>VMware Host Datastore Space Free GB Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.CollectionRule.HostDatastoreSpaceFreePercent">
          <Name>VMware Host Datastore Space Free Percent Collection</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostPowerState">
          <Name>VMware Host Power State</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostPowerState.AlertMessage">
          <Name>VMware Host Power State</Name>
          <Description>The current power state of the host is NOT powered on, the state is {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostPowerState" SubElementID="PoweredOn">
          <Name>PoweredOn</Name>
          <Description>PoweredOn</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.HostPowerState" SubElementID="NotPoweredOn">
          <Name>NotPoweredOn</Name>
          <Description>NotPoweredOn</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Network">
          <Name>VMware Network Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover Networks</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.NetworkOverallStatus">
          <Name>VMware Network Overall Status</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.NetworkOverallStatus.AlertMessage">
          <Name>VMware Network Overall Status</Name>
          <Description>The overall status of VMware network '{0}' is {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.NetworkOverallStatus" SubElementID="Healthy">
          <Name>Healthy</Name>
          <Description>Healthy</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.NetworkOverallStatus" SubElementID="Warning">
          <Name>Warning</Name>
          <Description>Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.NetworkOverallStatus" SubElementID="Critical">
          <Name>Critical</Name>
          <Description>Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.Rollup.HostsAndClusters">
          <Name>VMware Rollup - Hosts And Clusters Discovery</Name>
          <Description>PowerShell script that discovers Hosts and Clusters objects</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterClusterAvailability">
          <Name>Cluster Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresDatastoreAvailability">
          <Name>Datastore Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostHostPerformance">
          <Name>Host Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresDatastorePerformance">
          <Name>Datastore Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresDatastorePerformance">
          <Name>Datastore Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresPerformance">
          <Name>Datastore Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostHostAvailability">
          <Name>Host Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllStandaloneHostsHostPerformance">
          <Name>Standalone Host Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresDatastoreAvailability">
          <Name>Datastore Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.vCenterHostsAndClustersPerformance">
          <Name>Hosts and Clusters Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.vCenterHostsAndClustersAvailability">
          <Name>Hosts and Clusters Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.HostsAndClustersDatacenterAvailability">
          <Name>Datacenter Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.HostsAndClustersDatacenterPerformance">
          <Name>Datacenter Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllClustersPerformance">
          <Name>All Clusters Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllClustersClusterPerformance">
          <Name>Cluster Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllStandaloneHostsPerformance">
          <Name>All Standalone Hosts Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllClustersAvailability">
          <Name>All Clusters Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllClustersClusterAvailability">
          <Name>Cluster Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.DatacenterAllStandaloneHostsAvailability">
          <Name>All Standalone Hosts Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.AllStandaloneHostsHostAvailability">
          <Name>Standalone Host Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterClusterPerformance">
          <Name>Cluster Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostDatastoresAvailability">
          <Name>Datastore Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresPerformance">
          <Name>Datastore Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterDatastoresAvailability">
          <Name>Datastore Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksPerformance">
          <Name>Network Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksAvailability">
          <Name>Network Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksNetworkAvailability">
          <Name>Network Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostNetworksNetworkPerformance">
          <Name>Network Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksPerformance">
          <Name>Network Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksAvailability">
          <Name>Network Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksNetworkAvailability">
          <Name>Network Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterNetworksNetworkPerformance">
          <Name>Network Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsPerformance">
          <Name>vApp Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsvAppPerformance">
          <Name>vApp Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsvAppAvailability">
          <Name>vApp Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostvAppsAvailability">
          <Name>vApp Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppPerformance">
          <Name>vApp Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppsvAppPerformance">
          <Name>vApp Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppsvAppsAvailability">
          <Name>vApp Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClustervAppsAvailability">
          <Name>vApp Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesVirtualMachinePerformance">
          <Name>Virtual Machine Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesVirtualMachineAvailability">
          <Name>Virtual Machine Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinePerformance">
          <Name>Virtual Machine Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesAvailability">
          <Name>Virtual Machine Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesVirtualMachineAvailability">
          <Name>Virtual Machine Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesVirtualMachinePerformance">
          <Name>Virtual Machine Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesAvailability">
          <Name>Virtual Machine Availability</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.DependencyMonitor.Rollup.HostsAndClusters.ClusterVirtualMachinesPerformance">
          <Name>Virtual Machine Performance</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.SecureReference.RunAsProfile">
          <Name>Community - VMware Monitoring Profile</Name>
          <Description>This profile is used to remotely connect to vCenter within VMware monitoring workflows</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.vApp">
          <Name>VMware vApp Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover vApps</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.vAppHostAndClusterReference">
          <Name>VMware vApp Host and Cluster Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover vApp Host and Cluster Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.vAppStartedState">
          <Name>VMware vApp Started State</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.vAppStartedState.AlertMessage">
          <Name>VMware vApp Not Started</Name>
          <Description>The VMware vApp is not started, the current state is is {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.vAppStartedState" SubElementID="Started">
          <Name>Started</Name>
          <Description>Started</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.vAppStartedState" SubElementID="NotStarted">
          <Name>NotStarted</Name>
          <Description>NotStarted</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.vCenter">
          <Name>VMware vCenter Discovery</Name>
          <Description>PowerShell script that discovers a vCenter object for each vCenter Server Service discovered</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.vCenterServerService">
          <Name>VMware vCenter Server Service Discovery</Name>
          <Description>Discovers the vpxd service on Windows Servers</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.VirtualMachineDatastoreReference">
          <Name>VMware Virtual Machine Datastore Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Virtual Machine Datastore Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.VirtualMachine">
          <Name>VMware Virtual Machine Discovery</Name>
          <Description>PowerShell script that connects to vCenter to discover Virtual Machines </Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.VirtualMachineComputerRelationship">
          <Name>VMware Virtual Machine Computer Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Virtual Machine Computer Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.VirtualMachineHostReference">
          <Name>VMware Virtual Machine Host Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Virtual Machine Host Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Discovery.VirtualMachineNetworkReference">
          <Name>VMware Virtual Machine Network Reference Relationship Discovery</Name>
          <Description>PowerShell script that connects to SCOM to discover Virtual Machine Network Reference Relationships</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.VirtualMachinePowerState">
          <Name>VMware Virtual Machine Power State</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.VirtualMachinePowerState.AlertMessage">
          <Name>VMware Virtual Machine Power State</Name>
          <Description>The current power state of the virtual machine is not powered on, the state is {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.VirtualMachinePowerState" SubElementID="PoweredOn">
          <Name>PoweredOn</Name>
          <Description>PoweredOn</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.UnitMonitor.VirtualMachinePowerState" SubElementID="NotPoweredOn">
          <Name>NotPoweredOn</Name>
          <Description>NotPoweredOn</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Folder.Root">
          <Name>VMware</Name>
          <Description>Community VMware root view folder</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Folder.InventoryObjects">
          <Name>1. Inventory Objects</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware">
          <Name>Community - VMware</Name>
          <Description>Community developed monitoring for VMware</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.UnixReference">
          <Name>Community - Unix View For MP Reference</Name>
          <Description>Not Visible, only used to create MP reference for Microsoft.Unix.Library</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StatevCenter">
          <Name>3. vCenter Object States</Name>
          <Description>vCenter State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StateVirtualMachine">
          <Name>7. Virtual Machines</Name>
          <Description>Virtual Machine State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StateHost">
          <Name>3. Hosts</Name>
          <Description>Host State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.DaigramvCenterRollup">
          <Name>2. vCenter Topology Rollup</Name>
          <Description>vCenter Rollup Diagram View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StateCluster">
          <Name>2. Clusters</Name>
          <Description>Cluster State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StateDatastore">
          <Name>4. Datastores</Name>
          <Description>Datastore State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.AlertAllObjects">
          <Name>1. Active Alerts</Name>
          <Description>Active Alerts View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StateDatacenter">
          <Name>1. Datacenters</Name>
          <Description>Datacenter State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StateNetwork">
          <Name>5. Networks</Name>
          <Description>Network State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.View.StatevApp">
          <Name>6. vApps</Name>
          <Description>vApp State View</Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Cluster">
          <Name>Community - VMware - Cluster</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Cluster" SubElementID="ClusterName">
          <Name>Cluster Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Cluster" SubElementID="ClusterId">
          <Name>Cluster Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Cluster" SubElementID="HAEnabled">
          <Name>HA Enabled</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Datacenter">
          <Name>Community - VMware - Datacenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Datacenter" SubElementID="DatacenterName">
          <Name>Datacenter Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Datacenter" SubElementID="DatacenterId">
          <Name>Datacenter Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Datastore">
          <Name>Community - VMware - Datastore</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Datastore" SubElementID="DatastoreName">
          <Name>Datastore Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Datastore" SubElementID="DatastoreId">
          <Name>Datastore Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Group.AllObjects">
          <Name>Community - VMware All Objects Group</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Group.ClustersWithoutHA">
          <Name>Community - VMware Clusters Without HA Group</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Group.Rollup.vCenter">
          <Name>Community - VMware Rollup - vCenter Group</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Group.UnmonitoredVirtualMachines">
          <Name>Community - VMware Unmonitored Virtual Machines Group</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Host">
          <Name>Community - VMware - Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Host" SubElementID="HostName">
          <Name>Host Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Host" SubElementID="HostId">
          <Name>Host Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Host" SubElementID="IsStandalone">
          <Name>Is Standalone</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Network">
          <Name>Community - VMware - Network</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Network" SubElementID="NetworkName">
          <Name>Network Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Network" SubElementID="NetworkId">
          <Name>Network Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.ResourcePool">
          <Name>Community - VMware Monitoring</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.vCenter">
          <Name>Community - VMware Rollup - vCenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.vCenter" SubElementID="vCenterServerName">
          <Name>vCenter Server Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter">
          <Name>Community - VMware Rollup - Hosts and Clusters Datacenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" SubElementID="DatacenterName">
          <Name>Datacenter Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Datacenter" SubElementID="DatacenterId">
          <Name>Datacenter Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters">
          <Name>Community - VMware Rollup - All Clusters</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllClusters" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps">
          <Name>Community - VMware Rollup - Cluster vApps</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClustervApps" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts">
          <Name>Community - VMware Rollup - All Standalone Hosts</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.AllStandaloneHosts" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Cluster">
          <Name>Community - VMware Rollup - Cluster</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" SubElementID="ClusterName">
          <Name>Cluster Name</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.Cluster" SubElementID="ClusterId">
          <Name>Cluster Id</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks">
          <Name>Community - VMware Rollup - Cluster Networks</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterNetworks" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines">
          <Name>Community - VMware Rollup - Cluster Virtual Machines</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterVirtualMachines" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters">
          <Name>Community - VMware Rollup - Hosts and Clusters</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores">
          <Name>Community - VMware Rollup - Cluster Datastores</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.ClusterDatastores" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost">
          <Name>Community - VMware Rollup - Standalone Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" SubElementID="HostName">
          <Name>Host Name</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHost" SubElementID="HostId">
          <Name>Host Id</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines">
          <Name>Community - VMware Rollup - Standalone Host Virtual Machines</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostVirtualMachines" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores">
          <Name>Community - VMware Rollup - Standalone Host Datastores</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostDatastores" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks">
          <Name>Community - VMware Rollup - Standalone Host Networks</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostNetworks" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps">
          <Name>Community - VMware Rollup - Standalone Host vApps</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.Rollup.HostsAndClusters.StandaloneHostvApps" SubElementID="Name">
          <Name>Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.vApp">
          <Name>Community - VMware - vApp</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.vApp" SubElementID="vAppName">
          <Name>vApp Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.vApp" SubElementID="vAppId">
          <Name>vApp Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.vCenter">
          <Name>Community - VMware - vCenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.vCenter" SubElementID="vCenterServerName">
          <Name>vCenter Server Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.vCenterServerService">
          <Name>Community - VMware vCenter Server Service</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.VirtualMachine">
          <Name>Community - VMware - Virtual Machine</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.VirtualMachine" SubElementID="VirtualMachineName">
          <Name>Virtual Machine Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.VirtualMachine" SubElementID="VirtualMachineHostName">
          <Name>Virtual Machine Host Name</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Class.VirtualMachine" SubElementID="VirtualMachineId">
          <Name>Virtual Machine Id</Name>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.ClusterContainsHost">
          <Name>Community - VMware Cluster Contains Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.ClusterReferencesDatacenter">
          <Name>Community - VMware Cluster References Datacenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.HostReferencesDatacenter">
          <Name>Community - VMware Host References Datacenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.HostReferencesDatastore">
          <Name>Community - VMware Host References Datastore</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.HostReferencesNetwork">
          <Name>Community - VMware Host References Network</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.ResourcePoolHostsvCenter">
          <Name>Community - VMware Monitoring Resource Pool Hosts vCenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.vCenterHostsHostsAndClusters">
          <Name>Community - VMware Rollup - vCenter Hosts Hosts and Clusters</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClustersHostsDatacenter">
          <Name>Community - VMware Rollup - Hosts and Clusters Hosts Hosts and Clusters Datacenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllClusters">
          <Name>Community - VMware Rollup - Hosts and Clusters Datacenter Hosts All Clusters</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.DatacenterHostsAllStandaloneHosts">
          <Name>Community - VMware Rollup - Hosts and Clusters Datacenter Hosts All Standalone Hosts</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.AllClustersHostsCluster">
          <Name>Community - VMware Rollup - All Clusters Hosts Cluster</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsVirtualMachines">
          <Name>Community - VMware Rollup - Cluster Hosts Virtual Machines</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsDatastores">
          <Name>Community - VMware Rollup - Cluster Hosts Datastores</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsNetworks">
          <Name>Community - VMware Rollup - Cluster Hosts Networks</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterHostsvApps">
          <Name>Community - VMware Rollup - Cluster Hosts vApps</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.AllStandaloneHostsHostsStandaloneHost">
          <Name>Community - VMware Rollup - All Standalone Hosts Hosts Standalone Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsVirtualMachines">
          <Name>Community - VMware Rollup - Standalone Host Hosts Virtual Machines</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsDatastores">
          <Name>Community - VMware Rollup - Standalone Host Hosts Networks</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsNetworks">
          <Name>Community - VMware Rollup - Standalone Host Hosts Datastores</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostHostsvApps">
          <Name>Community - VMware Rollup - Standalone Host Hosts vApp</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterContainsCluster">
          <Name>Community - VMware Rollup - Cluster Rollup Contains Cluster</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterVirtualMachinesContainsVirtualMachine">
          <Name>Community - VMware Rollup - Cluster Virtual Machines Contains Virtual Machine</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterDatastoresContainsDatastore">
          <Name>Community - VMware Rollup - Cluster Datastores Contains Datastore</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClusterNetworksContainsNetwork">
          <Name>Community - VMware Rollup - Cluster Networks Contains Network</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.ClustervAppsContainsvApp">
          <Name>Community - VMware Rollup - Cluster vApps Contains vApp</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostContainsHost">
          <Name>Community - VMware Rollup - Standalone Host Rollup Contains Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostVirtualMachinesContainsVirtualMachine">
          <Name>Community - VMware Rollup - Standalone Host Virtual Machines Contains Virtual Machine</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostDatastoresContainsDatastore">
          <Name>Community - VMware Rollup - Standalone Host Datastores Contains Datastore</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostNetworksContainsNetwork">
          <Name>Community - VMware Rollup - Standalone Host Networks Contains Network</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.Rollup.HostsAndClusters.StandaloneHostvAppsContainsvApp">
          <Name>Community - VMware Rollup - Standalone Host vApps Contains vApp</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vAppReferencesCluster">
          <Name>Community - VMware - vApp References Cluster</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vAppReferencesHost">
          <Name>Community - VMware - vApp References Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsCluster">
          <Name>Community - VMware vCenter Hosts Cluster</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsDatacenter">
          <Name>Community - VMware vCenter Hosts Datacenter</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsDatastore">
          <Name>Community - VMware vCenter Hosts Datastore</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsHost">
          <Name>Community - VMware vCenter Hosts Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsNetwork">
          <Name>Community - VMware vCenter Hosts Network</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsvApp">
          <Name>Community - VMware vCenter Hosts vApp</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.vCenterHostsVirtualMachine">
          <Name>Community - VMware vCenter Hosts Virtual Machine</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.VirtualMachineReferencesDatastore">
          <Name>Community - VMware Virtual Machine References Datastore</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.VirtualMachineReferencesHost">
          <Name>Community - VMware Virtual Machine References Host</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Community.VMware.Relationship.VirtualMachineReferencesNetwork">
          <Name>Community - VMware Virtual Machine References Network</Name>
          <Description></Description>
        </DisplayString>
      </DisplayStrings>
      <KnowledgeArticles></KnowledgeArticles>
    </LanguagePack>
  </LanguagePacks>
  <Resources>
    <Image ID="Community.VMware.Image.Cluster.Diagram" FileName="Cluster_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Cluster Image Diagram" />
    <Image ID="Community.VMware.Image.Cluster.Small" FileName="Cluster_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Cluster Image Small" />
    <Image ID="Community.VMware.Image.Datacenter.Diagram" FileName="Datacenter_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Datacenter Image Diagram" />
    <Image ID="Community.VMware.Image.Datacenter.Small" FileName="Datacenter_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Datacenter Image Small" />
    <Image ID="Community.VMware.Image.Datastore.Diagram" FileName="Datastore_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Datastore Image Diagram" />
    <Image ID="Community.VMware.Image.Datastore.Small" FileName="Datastore_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Datastore Image Small" />
    <Image ID="Community.VMware.Image.Host.Diagram" FileName="Host_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Host Image Diagram" />
    <Image ID="Community.VMware.Image.Host.Small" FileName="Host_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Host Image Small" />
    <Image ID="Community.VMware.Image.Network.Diagram" FileName="Network_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Network Image Diagram" />
    <Image ID="Community.VMware.Image.Network.Small" FileName="Network_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Network Image Small" />
    <Image ID="Community.VMware.Image.vApp.Diagram" FileName="vApp_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware vApp Image Diagram" />
    <Image ID="Community.VMware.Image.vApp.Small" FileName="vApp_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware vApp Image Small" />
    <Image ID="Community.VMware.Image.vCenter.Diagram" FileName="vCenter_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware vCenter Image Diagram" />
    <Image ID="Community.VMware.Image.vCenter.Small" FileName="vCenter_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware vCenter Image Small" />
    <Image ID="Community.VMware.Image.VirtualMachine.Diagram" FileName="VirtualMachine_80.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Virtua lMachine Image Diagram" />
    <Image ID="Community.VMware.Image.VirtualMachine.Small" FileName="VirtualMachine_16.png" Accessibility="Public" HasNullStream="false" Comment="Community - VMware Virtual Machine Image Small" />
  </Resources>
</ManagementPack>